---
title: "BRC1 network"
output: html_notebook
---

```{r, include=FALSE}
# Data manipulation
library(tidyverse)
library(data.table)
library(GenomicRanges)
library(GenomicFeatures)
library(plyranges)

# Differential expression and ChIP analyses
library(edgeR)
library(csaw)

# Gene annotation
library(biomaRt)
library(AnnotationDbi)
library(org.At.tair.db)
library(GO.db)
library(clusterProfiler)
library(pathview)
library(GOSemSim)

ensembl = biomaRt::useMart(biomart="plants_mart",
                           dataset="athaliana_eg_gene",
                           host="https://plants.ensembl.org")
#View(listAttributes(ensembl))

# Sequence analysis
library(Biostrings)
library(BSgenome.Athaliana.TAIR.TAIR9)

# Data visualization
library(ggplot2)
library(ggpubr)
library(RColorBrewer)
library(circlize)
library(randomcoloR)
library(dendextend)
library(ComplexHeatmap)
library(EnrichedHeatmap)
library(simplifyEnrichment)
library(ggsci)
library(ggrepel)
library(ggpmisc)
library(directlabels)
library(WeightedCluster)
library(GGally)
library(ggsankey)
library(ggupset)
library(ggVennDiagram)
library(igraph)

# Load custom functions
invisible(sapply(list.files(path = "./R/", pattern = "\\.R$", ignore.case = TRUE, full.names = TRUE), source, .GlobalEnv))

# Set global ggplot theme parameters
theme_update(axis.text.x = element_text(color="black"), 
             axis.text.y = element_text(color="black"),
             axis.ticks = element_line(color="black"),
             panel.border = element_rect(color="black", fill = NA),
             panel.grid.major = element_blank(), 
             panel.grid.minor = element_blank(),
             panel.background = element_blank(),
             legend.background = element_blank(),
             plot.background = element_rect(fill = "transparent", color = NA),
             plot.title = element_text(hjust = 0.5))
```

GFP:BRC1 RNAseq
```{r}
# Define parameters for differential expression statistical tests
exp_name = paste0(format(Sys.Date(),"%Y_%m_%d_"), "GFPBRC1ind_")
feature_counts = fread("./input/BRC1ind_featureCounts.count")
feature_counts = feature_counts[,c(1:6,10:12,7:9)] # Rearrange columns to have controls as first columns
sample_names = c("brc1_1","brc1_2","brc1_3",
                 "GFP_BRC1ind_1","GFP_BRC1ind_2","GFP_BRC1ind_3")
sample_groups = gsub('.{2}$', '', sample_names) %>% factor(levels= unique(gsub('.{2}$', '', sample_names)))
design = model.matrix(~0+sample_groups) %>% `colnames<-`(levels(sample_groups))
my_contrasts = makeContrasts(GFP_BRC1ind_vs_brc1 = GFP_BRC1ind-brc1,
                             levels=design)

# Perform statistcal tests
brc1ind_results = difexp_analysis(feature_counts=feature_counts,
                                  exp_name=exp_name,
                                  sample_names=sample_names,
                                  sample_groups=sample_groups,
                                  design=design,
                                  my_contrasts=my_contrasts)

# Store results for downstream analyses
BRC1ind_data_unfiltered = brc1ind_results$merged_tests
BRC1ind_data = brc1ind_results$filtered_tests
BRC1ind_DGEL = brc1ind_results$DGEL

# Write rpkm and filtered fold changes to output
write.table(brc1ind_results$rpkm, file = paste0("./output/",exp_name,"RPKM.txt"), row.names=F, sep="\t", quote=F)
write.table(brc1ind_results$filtered_tests, file = paste0("./output/",exp_name,"filtered_tests.txt"), row.names=F, sep="\t", quote=F, na="")

### Data visualization
# MDS plot
DGEL_input = BRC1ind_DGEL
group_labels = c(brc1 = "brc1", GFP_BRC1ind = "GFP:BRC1ind")
col_palette = pal_jco("default")(4)[c(3,1)]

mds_plot = mds_ggplot(DGEL_input,group_labels,col_palette)

custom_width = 14
ggsave(mds_plot+theme(text = element_text(size=15)), 
       filename = "./output/mds_plot_GFPBRC1ind.png",
       dpi = 600,
       units = "cm",
       width = custom_width, height = custom_width/1.386568)

# Volcano plot
vp_input = BRC1ind_data_unfiltered
comparisons = find_tests(vp_input)
volc_plot = volcano_plot(vp_input,comparisons)

ggsave(volc_plot, 
       filename = "./output/volc_plot_GFPBRC1ind.png",
       dpi = 600,
       units = "cm",
       width = 16.93, height = 12.21)
```

BRC1 direct target analysis
```{r}
# Generate GRanges objects with information about gene coordinates
ath_gtf = read_gff("./input/Arabidopsis_thaliana.TAIR10.52.gtf.gz")
ath_genes = ath_gtf %>% filter(type == "gene")
tss = ath_genes %>% resize(width=1, fix='start') %>% select(gene_id) %>% `names<-`(.$gene_id) %>% sort

ext5 = 3000
ext3 = 1000
ath_3kup_1kdown = ath_genes %>% anchor_5p %>% mutate(width = 1) %>% stretch(ext5*2 - 1) %>%
  anchor_5p %>% stretch(ext3-ext5) %>% `mcols<-`(value = list("gene_id" = .$gene_id))

# Use MACS2-generated peak files with qvalue threshold 1, and then filter "manually" by qvalue < 0.05 and peak size 10-500 bp
qval_filter = -log10(0.05)
peak_max_width = 500
peak_min_width = 10

peak_files = list.files(path = "./input/", pattern = "^ChIP\\d_q1_peaks.narrowPeak$", all.files = TRUE, full.names = TRUE)
peak_file_names = str_match(peak_files, "ChIP\\d") %>% as.vector
peak_list = lapply(peak_files, read_narrowpeaks) %>% GRangesList() %>% `names<-`(peak_file_names)

filtered_peak_list = peak_list %>% 
  endoapply(function(x) plyranges::filter(x, qValue > qval_filter)) %>% 
  endoapply(function(x) plyranges::filter(x, (width > peak_min_width) & (width < peak_max_width)))

# Get "consensus peaks" (peaks that partially overlap in at least two replicates)
brc1_peaks = filtered_peak_list %>% get_consensus_peaks_GRangesList()

# Get direct target genes with BRC1ind differentially expressed genes and consensus peak files
#BRC1ind_data = brc1ind_results$filtered_tests # run in previous section
brc1_direct_targets = get_direct_targets(peak_file = brc1_peaks,
                                         de_file = BRC1ind_data,
                                         target_region = ath_3kup_1kdown,
                                         output = "vector")

# Generate input data for ComplexHeatmap. Check the ComplexHeatmap reference manual, it has lots of examples:
# https://jokergoo.github.io/ComplexHeatmap-reference/book/
# Input data has to be a matrix with gene ids as rownames (heatmap annotations are added by rowname)
heatmap_input = BRC1ind_data %>% 
  dplyr::select(c(Geneid, logFC_GFP_BRC1ind_vs_brc1)) %>% 
  column_to_rownames("Geneid") %>% 
  rename("GFP:BRC1ind" = logFC_GFP_BRC1ind_vs_brc1) %>% 
  as.matrix()

# Create heatmap annotation:
# named vector with 1/0 if BRC1 differentially expressed gene is a direct target (Geneids as names)
annotation_data = (BRC1ind_data$Geneid %in% brc1_direct_targets) %>% 
  `names<-`(BRC1ind_data$Geneid) %>% as.numeric()
# coloring function for the annotation:
anno_col_fun = colorRamp2(c(0, 1), c("white", "black")) 
# generate the HeatmapAnnotation:
ha = HeatmapAnnotation(brc1_dt = annotation_data,
                       which = "row",
                       annotation_name_gp = gpar(fontsize =6),
                       annotation_label = "BRC1_ChIP",
                       annotation_name_side = "top",
                       annotation_name_rot = 45,
                       show_legend = FALSE,
                       col = list(brc1_dt = anno_col_fun))


# Create heatmap with annotation. Check ComplexHeatmap for settings
brc1_heatmap = 
  Heatmap(heatmap_input,
          clustering_method_rows = "ward.D2",
          right_annotation = ha,
          show_row_names = FALSE,
          column_names_rot = 0,
          column_names_centered = TRUE,
          heatmap_legend_param = list(title = "log2(FC)")
  )

# If extreme FC values skew coloring function (a few genes are very highly up-/down-regulated),
# you can create a custom coloring function for the heatmap
custom_breaks = c(quantile(heatmap_input, .05), 0, quantile(heatmap_input, .95))
col_fun = colorRamp2(custom_breaks, c("blue", "white","red")) 

brc1_heatmap_custom_color_fun = 
  Heatmap(heatmap_input,
          col = col_fun,
          clustering_method_rows = "ward.D2",
          right_annotation = ha,
          show_row_names = FALSE,
          column_names_rot = 0,
          column_names_centered = TRUE,
          heatmap_legend_param = list(title = "log2(FC)")
  )

### To check if lower qvalues influence the direct target classification towards up-regulated genes
qval_filter = -log10(0.01)
brc1_peaks_0.01 = peak_list %>% 
  endoapply(function(x) plyranges::filter(x, qValue > qval_filter)) %>% 
  endoapply(function(x) plyranges::filter(x, (width > peak_min_width) & (width < peak_max_width))) %>% 
  get_consensus_peaks_GRangesList()

qval_filter = -log10(0.001)
brc1_peaks_0.001 = peak_list %>% 
  endoapply(function(x) plyranges::filter(x, qValue > qval_filter)) %>% 
  endoapply(function(x) plyranges::filter(x, (width > peak_min_width) & (width < peak_max_width))) %>% 
  get_consensus_peaks_GRangesList()

brc1_peak_list = GRangesList("q0.05" = brc1_peaks,
                             "q0.01" = brc1_peaks_0.01,
                             "q0.001" = brc1_peaks_0.001)
# this function generates a dataframe with a column for each peak file with 0/1 if genes are direct targets
anno_df = make_anno_df(de_genes = BRC1ind_data,
                       peak_list = brc1_peak_list,
                       target_region = ath_3kup_1kdown,
                       peak_name_column = "peak_name")

# as we have three columns in the annotation, we have to generate a coloring function for each of them (we could use different colors)
anno_col_fun = colorRamp2(c(0, 1), c("white", "black")) 
# make list with names of each column in df
col_fun_list = list()
for(i in colnames(anno_df)){
  col_fun_list[[i]] = anno_col_fun
}

ha = HeatmapAnnotation(df = anno_df,
                       which = "row",
                       annotation_name_gp = gpar(fontsize =6),
                       annotation_name_side = "top",
                       annotation_name_rot = 45,
                       show_legend = FALSE,
                       col = col_fun_list)
# create heatmap
brc1_heatmap_qvalues = 
  Heatmap(heatmap_input,
          clustering_method_rows = "ward.D2",
          right_annotation = ha,
          show_row_names = FALSE,
          column_names_rot = 0,
          column_names_centered = TRUE,
          heatmap_legend_param = list(title = "log2(FC)")
  )

### for Gema: to get DE genes for HBinds use:
hb21ind_data = hbind_results$list_by_contrast$hb21i_vs_gus


### Statistical test to check if BRC1ind up-regulated genes are enriched in BRC1 peaks
# https://statsandr.com/blog/chi-square-test-of-independence-in-r/
brc1_test_results = chisq_test(de_file = BRC1ind_data,
                               peak_file = brc1_peaks,
                               target_region = ath_3kup_1kdown,
                               total_genes = ath_genes$gene_id)
```

HBind RNAseq
```{r}
# Define parameters for differential expression statistical tests
exp_name = paste0(format(Sys.Date(),"%Y_%m_%d_"), "HBind_")
feature_counts = fread("./input/HBs_experiment_featureCounts.count")
sample_names = c("gus_1","gus_2","gus_3",
                 "hb21i_1","hb21i_2","hb21i_3",
                 "hb40i_1","hb40i_2","hb40i_3",
                 "hb53i_1","hb53i_2","hb53i_3")
sample_groups = gsub('.{2}$', '', sample_names) %>% factor(levels=unique(gsub('.{2}$', '', sample_names)))
design = model.matrix(~0+sample_groups) %>% `colnames<-`(levels(sample_groups))
my_contrasts = makeContrasts(hb21i_vs_gus=hb21i-gus,
                             hb40i_vs_gus=hb40i-gus,
                             hb53i_vs_gus=hb53i-gus,
                             levels=design)

# Perform statistcal tests
hbind_results = difexp_analysis(feature_counts=feature_counts,
                                exp_name=exp_name,
                                sample_names=sample_names,
                                sample_groups=sample_groups,
                                design=design,
                                my_contrasts=my_contrasts)

# Store results for downstream analyses
HBind_data_unfiltered = hbind_results$merged_tests
HBind_data = hbind_results$filtered_tests
HBind_DGEL = hbind_results$DGEL

# Write rpkm and filtered fold changes to output
write.table(hbind_results$rpkm, file = paste0("./output/",exp_name,"RPKM.txt"), row.names=F, sep="\t", quote=F)
write.table(hbind_results$filtered_tests, file = paste0("./output/",exp_name,"filtered_tests.txt"), row.names=F, sep="\t", quote=F, na="")

### Data visualization
# MDS plot
DGEL_input = HBind_DGEL
group_labels = c(gus = "GUSind",
                 hb21i = "HB21ind",
                 hb40i = "HB40ind",
                 hb53i = "HB53ind")
col_palette = pal_jco("default")(4)[c(3,1,2,4)]

mds_plot = mds_ggplot(DGEL_input,group_labels,col_palette)

custom_width = 12
ggsave(mds_plot+theme(text = element_text(size=15)), 
       filename = "./output/mds_plot_HBind.png",
       dpi = 600,
       units = "cm",
       width = custom_width, height = custom_width/1.386568)

# Volcano plot
vp_input = HBind_data_unfiltered
comparisons = find_tests(vp_input)
volc_plot_list = lapply(comparisons, volcano_plot, edger_merged_results = vp_input)
volc_plot = ggarrange(plotlist=volc_plot_list, ncol = 3)

ggsave(volc_plot, 
       filename = "./output/volc_plot_HBind.png",
       dpi = 600,
       units = "cm",
       width = 16.93*2, height = 12.21)
```

HBind analysis
```{r}
### Upset plot to see overlap
filtered_data = hbind_results$filtered_tests %>% column_to_rownames("Geneid") %>% 
  dplyr::select(logFC_hb21i_vs_gus,logFC_hb40i_vs_gus,logFC_hb53i_vs_gus) %>%
  `colnames<-`(c("HB21ind","HB40ind","HB53ind"))

gene_list = list()
i = 1
for(l in seq_along(hbind_results$list_by_contrast)) {
  de_list = hbind_results$list_by_contrast[l]
  list_name = names(de_list)
  fc_column = paste0("logFC_",list_name)
  up_genes = dplyr::filter(hbind_results$list_by_contrast[[l]], get(fc_column) > 1) %>% pull(Geneid) 
  gene_list[[i]] = up_genes
  i = i + 1
  dn_genes = dplyr::filter(hbind_results$list_by_contrast[[l]], get(fc_column) < 1) %>% pull(Geneid)
  gene_list[[i]] = dn_genes
  i = i + 1
}

names(gene_list) = paste0(c("HB21ind up (",
                            "HB21ind down   (",
                            "HB40ind up   (",
                            "HB40ind down   (",
                            "HB53ind up   (",
                            "HB53ind down   ("),
                          sapply(gene_list,length),
                          c(rep(")",6)))

# reorder list
gene_list = gene_list[c(1,3,5,2,4,6)]

ggupset_input = list_to_matrix(gene_list) %>% as.data.frame %>%
  rownames_to_column("GeneID") %>%
  gather(-GeneID, key = "sample", value = "value") %>%
  filter(value == 1) %>%
  dplyr::select(-value) %>%
  group_by(GeneID) %>%
  summarize(sample = list(sample), .groups = "drop_last")

# plot 
UPSET_plot = ggplot(ggupset_input, aes(x=sample)) +
  geom_bar() +
  scale_y_continuous("Number of\ncommon genes", expand = expansion(mult = c(0, 0.05))) +
  geom_text(stat = "count",
            aes(label=..count..),
            hjust = 0.5,
            vjust = -0.5,
            size = 3,
            angle = 0) +
  scale_x_upset(name = "", order_by = "freq",
                sets = c(names(gene_list)),
                n_intersections = Inf) +
  theme_classic() +
  theme(axis.text.x = element_text(color="black"),
        axis.text.y = element_text(color="black"),
        axis.ticks = element_line(color="black"),
        plot.margin = unit(c(5.5,5.5,5.5,53), "pt"))

ggsave(UPSET_plot, filename="./output/HBind_upsetplot.png",
       dpi = 600,
       units = "cm",
       width = 16.93, height = 12.21)

### Venn diagrams
x = gene_list[1:3] %>% `names<-`(c("HB21ind","HB40ind","HB53ind"))

custom_colors = c(rep("black", length(x)))

venn_up = 
  ggVennDiagram(x) +
  scale_color_manual(values = custom_colors) +
  scale_fill_gradient(low="white", high = "red") +
  scale_x_continuous(expand = expansion(mult = .2)) +
  labs(title="Up-regulated genes") +
  theme(legend.position = "none",
        plot.title = element_text(hjust = 0.5))

x = gene_list[4:6] %>% `names<-`(c("HB21ind","HB40ind","HB53ind"))

custom_colors = c(rep("black", length(x)))

venn_dn = 
  ggVennDiagram(x) +
  scale_color_manual(values = custom_colors) +
  scale_fill_gradient(low="white", high = "blue") +
  scale_x_continuous(expand = expansion(mult = .2)) +
  labs(title="Down-regulated genes") +
  theme(legend.position = "none",
        plot.title = element_text(hjust = 0.5))

ggsave(venn_up, filename="./output/HBind_up_venn.png",
       dpi = 600,
       units = "cm",
       width = 10, height = 10)

ggsave(venn_dn, filename="./output/HBind_dn_venn.png",
       dpi = 600,
       units = "cm",
       width = 10, height = 10)

### Sankey plot
test = data.frame(gene_id = filtered_data %>% rownames) %>% 
  mutate(HB21ind = case_when(
    gene_id %in% gene_list$`HB21ind up (2005)` ~ "up",
    gene_id %in% gene_list$`HB21ind down   (1116)` ~ "dn",
    TRUE ~ "ns")) %>% 
  mutate(HB40ind = case_when(
    gene_id %in% gene_list$`HB40ind up   (675)` ~ "up",
    gene_id %in% gene_list$`HB40ind down   (254)` ~ "dn",
    TRUE ~ "ns")) %>% 
  mutate(HB53ind = case_when(
    gene_id %in% gene_list$`HB53ind up   (656)` ~ "up",
    gene_id %in% gene_list$`HB53ind down   (209)` ~ "dn",
    TRUE ~ "ns"))

df = test %>%
  make_long(HB21ind, HB40ind, HB53ind)

hbind_sankey_plot = ggplot(df, aes(x = x, 
                                   next_x = next_x,
                                   node = node, 
                                   next_node = next_node, 
                                   fill = factor(node), 
                                   label = node)) +
  geom_sankey(flow.alpha = 0.5, 
              node.color = "black",
              show.legend = TRUE) +
  scale_x_discrete(expand = expansion(mult = 0.1)) +
  scale_fill_manual(values = c("up" = "red",
                               "ns" = "gray",
                               "dn" = "blue"),
                    breaks = c("up", "ns", "dn"),
                    labels = c("Up-reg.", "Not sig.", "Down-reg.")) +
  labs(fill = "Direction") +
  theme(axis.text.x = element_text(size = 14),
        axis.title = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        panel.grid = element_blank())

ggsave(hbind_sankey_plot, filename = "./output/HBind_sankeyplot.png",
       dpi = 600,
       units = "cm",
       width = 12, height = 10)

### Check if top up-regulated genes in HB21 are also top up-regulated genes in other HBinds
test_func = function(n){
  gene_list = list()
  i = 1
  for(l in seq_along(hbind_results$list_by_contrast)) {
    de_list = hbind_results$list_by_contrast[l]
    list_name = names(de_list)
    fc_column = paste0("logFC_",list_name)
    
    up_genes= slice_max(hbind_results$list_by_contrast[[l]], get(fc_column), n = n) %>% dplyr::select(c(Geneid, fc_column))
    gene_list[[i]] = up_genes
    i = i + 1
    # dn_genes= slice_min(hbind_results$list_by_contrast[[l]], get(fc_column), n = n) %>% dplyr::select(c(Geneid, fc_column))
    # gene_list[[i]] = dn_genes
    # i = i + 1
  }
  
  names(gene_list) = c("HB21ind up",
                       #"HB21ind down",
                       "HB40ind up",
                       #"HB40ind down",
                       "HB53ind up")
  #"HB53ind down")
  
  x = gene_list %>% lapply(function(x) pull(x,Geneid))
  
  custom_colors = c(rep("black", length(x)))
  
  ggVennDiagram(x, label= "count",category.names = c("HB21ind","HB40ind","HB53ind")) +
    scale_color_manual(values = custom_colors) +
    scale_fill_gradient(low="white", high = "red") +
    scale_x_continuous(expand = expansion(mult = .2)) +
    labs(title=paste0(n," top up-regulated genes")) +
    theme(legend.position = "none",
          plot.title = element_text(hjust = 0.5))
}

n_vector = c(50,100,200,300,400,500)

test = lapply(n_vector, test_func)

plot_upgenes = ggarrange(plotlist = test)

ggsave(plot_upgenes, filename = "./output/HBind_top_x_genes.png",
       dpi = 600,
       units = "cm",
       width = 30, height = 20)

### Heatmap with DAPseq data 
ath_gtf = read_gff("./input/Arabidopsis_thaliana.TAIR10.52.gtf.gz")
ath_genes = ath_gtf %>% filter(type == "gene")
tss = ath_genes %>% resize(width=1, fix='start') %>% select(gene_id) %>% `names<-`(.$gene_id) %>% sort

ath_3kup_1kdown = ath_genes %>% anchor_5p %>% mutate(width = 1) %>% stretch(5999) %>%
  anchor_5p %>% stretch(-2000) %>% `mcols<-`(value = list("gene_id" = .$gene_id))

qval_filter = -log10(0.05)
peak_max_width = 500
peak_min_width = 10

peak_files = list.files(path = "./input/", pattern = "^DAP_ATHB\\d{2}_q1_es200_peaks.narrowPeak$", all.files = TRUE, full.names = TRUE)
peak_file_names = str_match(peak_files, "DAP_ATHB\\d{2}") %>% as.vector
peak_list = lapply(peak_files, read_narrowpeaks) %>% GRangesList() %>% `names<-`(peak_file_names)

filtered_peak_list = peak_list %>% endoapply(function(x) plyranges::filter(x, qValue > qval_filter)) %>% 
  endoapply(function(x) plyranges::filter(x, (width > peak_min_width) & (width < peak_max_width)))

hb_peaks = filtered_peak_list %>% endoapply(function(x) plyranges::mutate(x, peak_name = paste0("peak_", rep(1:length(x)))))

anno_df = make_anno_df(hbind_results$filtered_tests, hb_peaks,
                       target_region = ath_3kup_1kdown,
                       peak_name_column = "peak_name")

ht_input = hbind_results$filtered_tests %>% 
  dplyr::select(c(Geneid, starts_with("logFC"))) %>% 
  column_to_rownames("Geneid") %>% as.matrix() %>% 
  `colnames<-`(c("HB21ind","HB40ind","HB53ind"))

anno_col_fun = colorRamp2(c(0, 1), c("white", "black")) 

col_fun_list = list()
for(i in colnames(anno_df)){
  col_fun_list[[i]] = anno_col_fun
}

ha = HeatmapAnnotation(df = anno_df,
                       which = "row",
                       annotation_name_gp = gpar(fontsize =6),
                       # annotation_label = c("brc1 de","brc1 array","BRC1 csaw","BRC1 q005", "BRC1 q001", "BRC1 q0001",
                       #                      "HB21 Dapseq","HB40 Dapseq","HB53 Dapseq"),
                       annotation_name_side="top",
                       annotation_name_rot=45,
                       show_legend = FALSE,
                       col = col_fun_list)

custom_breaks = c(quantile(ht_input, .05), 0, quantile(ht_input, .95))

col_fun = colorRamp2(custom_breaks, c("blue", "white","red")) 

hbind_heatmap = 
  Heatmap(ht_input,
          col = col_fun,
          clustering_method_rows = "ward.D2",
          right_annotation = ha,
          show_row_names = FALSE,
          column_names_rot = 0,
          column_names_centered = TRUE,
          heatmap_legend_param = list(title = "log2(FC)")
          #show_column_names = FALSE
  )

png("./output/HBind_heatmap.png", width = 15, height = 15, units = "cm", res = 600)
draw(hbind_heatmap)
dev.off()

### Statistical analysis
#hb_peaks
#hbind_results$list_by_contrast
ath_genes = plyranges::read_gff("./input/Arabidopsis_thaliana.TAIR10.52.gtf.gz") %>%
  filter(type == "gene") %>% as.data.frame() %>% 
  filter(seqnames %in% c(1,2,3,4,5)) %>% pull(gene_id)

hb_test_results = mapply(chisq_test, hbind_results$list_by_contrast, hb_peaks,
                         MoreArgs = list(target_region = ath_3kup_1kdown, 
                                         verbose = TRUE,
                                         total_genes = ath_genes), 
                         SIMPLIFY = FALSE)

# random test
# test_input = HBind_data_unfiltered %>% select(c(Geneid, logFC_hb21i_vs_gus))
# chisq_test(test_input, hb_peaks$DAP_ATHB21, target_region = ath_3kup_1kdown,total_genes = ath_genes)
# 
# test_input2 = test_input[sample(nrow(test_input), 1000), ] %>% 
#   mutate(logFC_hb21i_vs_gus = rnorm(nrow(.), sd = 3))
# chisq_test(test_input2, hb_peaks$DAP_ATHB21, target_region = ath_3kup_1kdown,total_genes = ath_genes)


```

ABA treatment RNAseq: wt, brc1, hb21hb40hb53; control/+ABA
```{r}
# Define parameters for differential expression statistical tests
exp_name = paste0(format(Sys.Date(),"%Y_%m_%d"), "_ABA_")
feature_counts = fread("./input/ABA_experiment_featureCounts.count")
sample_names = c("wt_ctr_1","wt_ctr_2","wt_ctr_3",
                 "wt_aba_1","wt_aba_2","wt_aba_3",
                 "tri_ctr_1","tri_ctr_2","tri_ctr_3",
                 "tri_aba_1","tri_aba_2","tri_aba_3",
                 "brc1_ctr_1","brc1_ctr_2","brc1_ctr_3",
                 "brc1_aba_1","brc1_aba_2","brc1_aba_3")
sample_groups = gsub('.{2}$', '', sample_names) %>% factor(levels=unique(gsub('.{2}$', '', sample_names)))
design = model.matrix(~0+sample_groups) %>% `colnames<-`(levels(sample_groups))
my_contrasts = makeContrasts(brc1_ctr_vs_wt_ctr=brc1_ctr-wt_ctr,
                             tri_ctr_vs_wt_ctr=tri_ctr-wt_ctr,
                             wt_aba_vs_wt_ctr=wt_aba-wt_ctr,
                             brc1_aba_vs_brc1_ctr=brc1_aba-brc1_ctr,
                             tri_aba_vs_tri_ctr=tri_aba-tri_ctr,
                             levels=design)

# Perform statistcal tests
aba_results = difexp_analysis(feature_counts=feature_counts,
                              exp_name=exp_name,
                              sample_names=sample_names,
                              sample_groups=sample_groups,
                              design=design,
                              my_contrasts=my_contrasts,
                              filter_by = "RPKM_cutoff",
                              RPKM_cutoff = 1)

# Store results for downstream analyses
aba_data_unfiltered = aba_results$merged_tests
aba_data = aba_results$filtered_tests
aba_DGEL = aba_results$DGEL

# Write rpkm and filtered fold changes to output
write.table(aba_results$rpkm, file = paste0("./output/",exp_name,"RPKM.txt"), row.names=F, sep="\t", quote=F)
write.table(aba_results$filtered_tests, file = paste0("./output/",exp_name,"filtered_tests.txt"), row.names=F, sep="\t", quote=F, na="")

### Data visualization
# MDS plot
DGEL_input = aba_DGEL
group_labels = c(wt_ctr = "wt",
                 wt_aba = "wt + ABA",
                 tri_ctr = "hb21hb40hb53",
                 tri_aba = "hb21hb40hb53 + ABA",
                 brc1_ctr = "brc1",
                 brc1_aba = "brc1 + ABA")
col_palette = c("#868686FF","#565656","#0073C2FF", "#005693","#EFC000FF", "#BE9800")

mds_plot = mds_ggplot(DGEL_input,group_labels,col_palette)

custom_width = 16
ggsave(mds_plot+theme(text = element_text(size=15)), 
       filename = "./output/mds_plot_ABA.png",
       dpi = 600,
       units = "cm",
       width = custom_width, height = custom_width/1.386568)

# Volcano plot (with FC > 2 threshold)
vp_input = aba_data_unfiltered
comparisons = find_tests(vp_input)
volc_plot_list = lapply(comparisons, volcano_plot, edger_merged_results = vp_input, logfc_threshold = 1)

volc_plot1 = ggarrange(plotlist=volc_plot_list[1:2], ncol = 2)
volc_plot2 = ggarrange(plotlist=volc_plot_list[3:5], ncol = 3)

ggsave(volc_plot1, 
       filename = "./output/volc_plot_brc1_triple.png",
       dpi = 600,
       units = "cm",
       width = 16.93*(4/3), height = 12.21)

ggsave(volc_plot2, 
       filename = "./output/volc_plot_ABA.png",
       dpi = 600,
       units = "cm",
       width = 16.93*2, height = 12.21)

### Analysis without FC filtering
# Perform statistcal tests
aba_results = difexp_analysis(feature_counts=feature_counts,
                              exp_name=exp_name,
                              sample_names=sample_names,
                              sample_groups=sample_groups,
                              design=design,
                              my_contrasts=my_contrasts,
                              FCts = log2(1))

# Store results for downstream analyses
aba_data_unfiltered = aba_results$merged_tests
aba_data = aba_results$filtered_tests
aba_DGEL = aba_results$DGEL

# Write rpkm and filtered fold changes to output
#write.table(aba_results$rpkm, file = paste0("./output/",exp_name,"RPKM.txt"), row.names=F, sep="\t", quote=F)
write.table(aba_results$filtered_tests, file = paste0("./output/",exp_name,"filtered_tests_no_fc_cut.txt"), 
            row.names=F, sep="\t", quote=F, na="")


# Volcano plot (without FC > 2 threshold)
vp_input = aba_data_unfiltered
comparisons = find_tests(vp_input)
volc_plot_list = lapply(comparisons, volcano_plot, edger_merged_results = vp_input,logfc_threshold = 0)

volc_plot1 = ggarrange(plotlist=volc_plot_list[1:2], ncol = 2)
ggsave(volc_plot1, 
       filename = "./output/volc_plot_brc1_triple_no_fc_cut.png",
       dpi = 600,
       units = "cm",
       width = 16.93*(4/3), height = 12.21)

volc_plot2 = ggarrange(plotlist=volc_plot_list[3:5], ncol = 3)
ggsave(volc_plot2, 
       filename = "./output/volc_plot_ABA_no_fc_cut.png",
       dpi = 600,
       units = "cm",
       width = 16.93*2, height = 12.21)
```

ABA treatment analysis
```{r}
library(GGally)

aba_results = difexp_analysis(feature_counts=feature_counts,
                              exp_name=exp_name,
                              sample_names=sample_names,
                              sample_groups=sample_groups,
                              design=design,
                              my_contrasts=my_contrasts,
                              FCts = log2(1))

aba_responding_genes = aba_results$list_by_contrast$wt_aba_vs_wt_ctr %>% filter(abs(logFC_wt_aba_vs_wt_ctr) > 1)
aba_up_genes = aba_responding_genes %>% filter(logFC_wt_aba_vs_wt_ctr > 1) %>% pull(Geneid)
aba_dn_genes = aba_responding_genes %>% filter(logFC_wt_aba_vs_wt_ctr < 1) %>% pull(Geneid)

ggplot(aba_responding_genes, aes(x= logCPM_wt_aba_vs_wt_ctr, y=logFC_wt_aba_vs_wt_ctr ))+
  geom_point()

aba_responding_rpkm = aba_results$rpkm %>% filter(gene_id %in% aba_responding_genes$Geneid) %>% 
  mutate(ave_wt_ctr = rowMeans(select(.,starts_with("wt_ctr")))) %>% 
  mutate(ave_wt_aba = rowMeans(select(.,starts_with("wt_aba")))) %>% 
  mutate(ave_brc1_ctr = rowMeans(select(.,starts_with("brc1_ctr")))) %>% 
  mutate(ave_brc1_aba = rowMeans(select(.,starts_with("brc1_aba")))) %>% 
  mutate(ave_tri_ctr = rowMeans(select(.,starts_with("tri_ctr")))) %>% 
  mutate(ave_tri_aba = rowMeans(select(.,starts_with("tri_aba")))) %>% 
  select(c(gene_id,starts_with("ave_")))

aba_up_rpkm = aba_responding_rpkm %>% filter(gene_id %in% aba_up_genes) %>% select(-gene_id) %>% log2
aba_dn_rpkm = aba_responding_rpkm %>% filter(gene_id %in% aba_dn_genes) %>% select(-gene_id) %>% log2

lowerfun = function(data,mapping){
  ggplot(data = data, mapping = mapping) +
    geom_point() +
    geom_abline(intercept = 0, slope = 1, color = "gray")
}

plot_aba_up = ggpairs(aba_up_rpkm,
                      lower = list(continuous = wrap(lowerfun)),
                      upper = list(continuous = wrap(lowerfun))) +
  labs(title="ABA up-regulated genes")+
  theme(plot.title = element_text(hjust = 0.5))

ggsave(plot_aba_up, 
       filename = "./output/corr_plot_aba_up.png",
       dpi = 600,
       units = "cm",
       width = 16.93, height = 16.93)

plot_aba_dn = ggpairs(aba_dn_rpkm,
                      lower = list(continuous = wrap(lowerfun)),
                      upper = list(continuous = wrap(lowerfun)))+
  labs(title="ABA down-regulated genes")+
  theme(plot.title = element_text(hjust = 0.5))

ggsave(plot_aba_dn, 
       filename = "./output/corr_plot_aba_dn.png",
       dpi = 600,
       units = "cm",
       width = 16.93, height = 16.93)

###
volcano_plot2 = function(edger_merged_results,
                         comparison = NULL,
                         gene_id_column = "Geneid",
                         col_up = "black",
                         col_ns = "white") {
  
  # obtain column name of logFC and FDR data depending on comparison name
  logfc_column = paste0("logFC_",comparison)
  fdr_column = paste0("FDR_",comparison)
  
  # manipulate edger object to specify which points are colored
  vp_input = edger_merged_results %>% as.data.frame %>% 
    select(all_of(c(gene_id_column,logfc_column,fdr_column))) %>% 
    mutate(log10_fdr = -log10(get(fdr_column))) %>% 
    mutate(vp_color = case_when(
      (Geneid %in% aba_responding_genes$Geneid) ~ "aba_resp",
      TRUE ~ "non_s")) %>% 
    filter(vp_color == "aba_resp")
  
  # generate the plot
  vplot = ggplot(vp_input, aes(x=get(logfc_column),y=log10_fdr,color=vp_color))+
    geom_point(shape=16, alpha = 0.5) +
    scale_x_continuous(limits = symmetric_limits) +
    scale_color_manual(values = c("aba_resp" = col_up,
                                  "non_s" = col_ns)) +
    labs(title = comparison,
         x = "log2(fold change)",
         y = "-log10(adj. p-val)") +
    coord_cartesian(clip = "off") +
    geom_hline(yintercept = -log10(0.05)) +
    geom_vline(xintercept = 1) +
    geom_vline(xintercept = -1) +
    theme(legend.position="none",
          plot.title = element_text(hjust = 0.5))
  
  return(vplot)
}

vp_input = aba_data_unfiltered
comparisons = find_tests(vp_input)
volc_plot_list = lapply(comparisons, volcano_plot2, edger_merged_results = vp_input)

volc_plot1 = ggarrange(plotlist=volc_plot_list[1:2], ncol = 2)
ggsave(volc_plot1, 
       filename = "./output/volc_plot_brc1_triple_aba_resp.png",
       dpi = 600,
       units = "cm",
       width = 16.93*(4/3), height = 12.21)

volc_plot2 = ggarrange(plotlist=volc_plot_list[3:5], ncol = 3)
ggsave(volc_plot2, 
       filename = "./output/volc_plot_ABA_aba_resp.png",
       dpi = 600,
       units = "cm",
       width = 16.93*2, height = 12.21)

##### Without selecting by FC
aba_responding_genes = aba_results$list_by_contrast$wt_aba_vs_wt_ctr %>% filter(abs(logFC_wt_aba_vs_wt_ctr) > 0)
aba_up_genes = aba_responding_genes %>% filter(logFC_wt_aba_vs_wt_ctr > 0) %>% pull(Geneid)
aba_dn_genes = aba_responding_genes %>% filter(logFC_wt_aba_vs_wt_ctr < 0) %>% pull(Geneid)

ggplot(aba_responding_genes, aes(x= logCPM_wt_aba_vs_wt_ctr, y=logFC_wt_aba_vs_wt_ctr ))+
  geom_point()

aba_responding_rpkm = aba_results$rpkm %>% filter(gene_id %in% aba_responding_genes$Geneid) %>% 
  mutate(ave_wt_ctr = rowMeans(select(.,starts_with("wt_ctr")))) %>% 
  mutate(ave_wt_aba = rowMeans(select(.,starts_with("wt_aba")))) %>% 
  mutate(ave_brc1_ctr = rowMeans(select(.,starts_with("brc1_ctr")))) %>% 
  mutate(ave_brc1_aba = rowMeans(select(.,starts_with("brc1_aba")))) %>% 
  mutate(ave_tri_ctr = rowMeans(select(.,starts_with("tri_ctr")))) %>% 
  mutate(ave_tri_aba = rowMeans(select(.,starts_with("tri_aba")))) %>% 
  dplyr::select(c(gene_id, starts_with("ave_")))

aba_up_rpkm = aba_responding_rpkm %>% filter(gene_id %in% aba_up_genes) %>% select(-gene_id) %>% log2
aba_dn_rpkm = aba_responding_rpkm %>% filter(gene_id %in% aba_dn_genes) %>% select(-gene_id) %>% log2

lowerfun = function(data,mapping){
  ggplot(data = data, mapping = mapping) +
    geom_point() +
    geom_abline(intercept = 0, slope = 1, color = "gray")
}

plot_aba_up = ggpairs(aba_up_rpkm,
                      lower = list(continuous = wrap(lowerfun)),
                      upper = list(continuous = wrap(lowerfun))) +
  labs(title="ABA up-regulated genes")+
  theme(plot.title = element_text(hjust = 0.5))

ggsave(plot_aba_up, 
       filename = "./output/corr_plot_aba_up_no_cut.png",
       dpi = 600,
       units = "cm",
       width = 16.93, height = 16.93)

plot_aba_dn = ggpairs(aba_dn_rpkm,
                      lower = list(continuous = wrap(lowerfun)),
                      upper = list(continuous = wrap(lowerfun)))+
  labs(title="ABA down-regulated genes")+
  theme(plot.title = element_text(hjust = 0.5))

ggsave(plot_aba_dn, 
       filename = "./output/corr_plot_aba_dn_no_cut.png",
       dpi = 600,
       units = "cm",
       width = 16.93, height = 16.93)

###
vp_input = aba_data_unfiltered
comparisons = find_tests(vp_input)
volc_plot_list = lapply(comparisons, volcano_plot2, edger_merged_results = vp_input)

volc_plot1 = ggarrange(plotlist=volc_plot_list[1:2], ncol = 2)
ggsave(volc_plot1, 
       filename = "./output/volc_plot_brc1_triple_aba_resp_no_cut.png",
       dpi = 600,
       units = "cm",
       width = 16.93*(4/3), height = 12.21)

volc_plot2 = ggarrange(plotlist=volc_plot_list[3:5], ncol = 3)
ggsave(volc_plot2, 
       filename = "./output/volc_plot_ABA_aba_resp_no_cut.png",
       dpi = 600,
       units = "cm",
       width = 16.93*2, height = 12.21)

#### Check Coefficient of Variation of ABA-responding genes
cv = function(x) {sd(x)/mean(x)*100}

library(emmeans)
library(multcomp)
library(multcompView)
##### Coefficient of variation of ABA-responding genes (FC>2)
aba_responding_genes = aba_results$list_by_contrast$wt_aba_vs_wt_ctr %>% filter(abs(logFC_wt_aba_vs_wt_ctr) > 1)

aba_responding_rpkm_cv = aba_results$rpkm %>% 
  filter(gene_id %in% aba_responding_genes$Geneid) %>% 
  pivot_longer(-gene_id) %>% 
  mutate(group = gsub('.{2}$', '', name)) %>% 
  group_by(gene_id, group) %>% 
  summarize(cv = cv(value), .groups = "drop_last")

data_summary = aba_responding_rpkm_cv %>% group_by(group) %>% summarize(cv_mean = mean(cv), cv_sd = sd(cv), max_cv = max(cv))

# get compact letter display with emmeans (in case groups are not balanced)
model_means_cld = lm(cv ~ group, data = aba_responding_rpkm_cv) %>% 
  emmeans(specs = "group") %>% cld(adjust = "tukey", 
                                   Letters = letters, 
                                   alpha = 0.05)
# format cld output for ggplot
cld_labels = model_means_cld %>% 
  as.data.frame() %>% rename(cld = ".group") %>% 
  left_join(dplyr::select(data_summary, c(group, max_cv)), by = "group") %>% 
  mutate(cld_label = trimws(cld))

# plot data
ggplot(aba_responding_rpkm_cv, aes(x = group, y = cv)) +
  geom_boxplot() +
  geom_text(data = cld_labels, 
            aes(label = cld_label, y = max_cv),
            vjust = -0.5)

##### Coefficient of variation of ABA-responding genes (no FC cut)
aba_responding_genes = aba_results$list_by_contrast$wt_aba_vs_wt_ctr %>% filter(abs(logFC_wt_aba_vs_wt_ctr) > 0)

aba_responding_rpkm_cv = aba_results$rpkm %>% 
  filter(gene_id %in% aba_responding_genes$Geneid) %>% 
  pivot_longer(-gene_id) %>% 
  mutate(group = gsub('.{2}$', '', name)) %>% 
  group_by(gene_id, group) %>% 
  summarize(cv = cv(value), .groups = "drop_last")

data_summary = aba_responding_rpkm_cv %>% group_by(group) %>% summarize(cv_mean = mean(cv), cv_sd = sd(cv), max_cv = max(cv))

# get compact letter display with emmeans (in case groups are not balanced)
model_means_cld = lm(cv ~ group, data = aba_responding_rpkm_cv) %>% 
  emmeans(specs = "group") %>% cld(adjust = "tukey", 
                                   Letters = letters, 
                                   alpha = 0.05)
# format cld output for ggplot
cld_labels = model_means_cld %>% 
  as.data.frame() %>% rename(cld = ".group") %>% 
  left_join(dplyr::select(data_summary, c(group, max_cv)), by = "group") %>% 
  mutate(cld_label = trimws(cld))

# plot data
ggplot(aba_responding_rpkm_cv, aes(x = group, y = cv)) +
  geom_boxplot() +
  geom_text(data = cld_labels, 
            aes(label = cld_label, y = max_cv),
            vjust = -0.5)


##### Coefficient of variation of all genes
all_genes_rpkm_cv = aba_results$rpkm %>% 
  pivot_longer(-gene_id) %>% 
  mutate(group = gsub('.{2}$', '', name)) %>% 
  group_by(gene_id, group) %>% 
  summarize(cv = cv(value), .groups = "drop_last") %>% 
  drop_na

data_summary = all_genes_rpkm_cv %>% group_by(group) %>% summarize(cv_mean = mean(cv), cv_sd = sd(cv), max_cv = max(cv))

# get compact letter display with emmeans (in case groups are not balanced)
model_means_cld = lm(cv ~ group, data = all_genes_rpkm_cv) %>% 
  emmeans(specs = "group") %>% cld(adjust = "tukey", 
                                   Letters = letters, 
                                   alpha = 0.05)
# format cld output for ggplot
cld_labels = model_means_cld %>% 
  as.data.frame() %>% rename(cld = ".group") %>% 
  left_join(dplyr::select(data_summary, c(group, max_cv)), by = "group") %>% 
  mutate(cld_label = trimws(cld))

# plot data
ggplot(all_genes_rpkm_cv, aes(x = group, y = cv)) +
  geom_boxplot() +
  geom_text(data = cld_labels, 
            aes(label = cld_label, y = max_cv),
            vjust = -0.5)
```

Integration of results into the BRC1-network

```{r}
### Find availabe data and tools to study ABA GRN
# Import BRC1-dependent ABA_GRN from Gonzalez-Grandio et al., 2017 - https://doi.org/10.1073/pnas.1613199114
ABA_GRN_CORE = fread("./input/BRC1-dep_ABA-GRN_CORE_PNAS2017.txt") %>% 
  add_gene_annotation(gene_id_column = "gene_id", tidy_output = FALSE)

# Retrieve GO information about Transcription factors
tx_factor_gos = AnnotationDbi::select(GO.db, 
                                      keys=c("GO:0003700","GO:0140110","GO:0006355","GO:0010468"),
                                      columns=c("GOID","TERM","DEFINITION"),
                                      keytype="GOID")

# Retrieve GO annotation for ABA_GRN genes (we will focus on DNA-binding transcription factors - GO:0003700)
ABA_GRN_CORE_TFs = AnnotationDbi::select(org.At.tair.db, 
                                         keys = ABA_GRN_CORE$gene_id,
                                         columns = c("TAIR", "GOALL"),
                                         keytype = "TAIR") %>% 
  filter(GOALL %in% c("GO:0003700")) %>% dplyr::select(c("TAIR","GOALL")) %>% unique %>% 
  rename("gene_id" = TAIR) %>% add_gene_annotation(gene_id_column = "gene_id", tidy_output = FALSE) %>% 
  dplyr::select(c("gene_id", "gene_symbol", "short_description"))

# Check availability in TRANSPLANTA and DAPseq/Chip-seq:
# Import available ChIP-seq experiments from Song et al., 2016 - https://doi.org/10.1126/science.aag1550
Ecker_ChIPseq_symbols = fread("./input/aag1550_table_s3.txt", skip = 1) %>% 
  pull(`#transgene`) %>% 
  replace(. == "At5g04760", "DIV2") %>%
  replace(. == "NFYB2", "NF-YB2") %>% 
  replace(. == "NFYC2", "NF-YC2") %>% 
  replace(. == "HB7", "HB-7") %>% 
  replace(. == "ANAC032", "NAC032")

Ecker_ChIPseq = AnnotationDbi::select(org.At.tair.db, 
                                      keys = test,
                                      columns = c("SYMBOL", "TAIR"),
                                      keytype = "SYMBOL") %>% 
  filter(!SYMBOL %in% c("DTAF1","DTAF2")) %>% 
  rename("gene_id" = TAIR)

# Import available DAP-seq experiments from O'Malley et al., 2016 - https://doi.org/10.1016/j.cell.2016.04.038
Ecker_DAPseq = fread("./input/OMalley_S1D.txt") %>% 
  dplyr::select(c("AT_ID", "Protein")) %>% 
  rename("gene_id" = AT_ID)

# Import TRANSPLANTA lines (Table S2 - TFs cloned in pER8GW vector) from Coego et al., 2014 - https://doi.org/10.1111/tpj.12443
transplanta_TFs = fread("./input/TRANSPLANTA_S2.txt", skip = 1) %>% 
  mutate(gene_id = gsub("\\..*","",`AGI code`) , 
         .before = `AGI code`)

transplanta_lines = fread("./input/TRANSPLANTA_S3.txt") %>% 
  mutate(gene_id = paste0("AT",
                          str_split(agi_code, "\\.", simplify = TRUE)[,1],
                          "G",
                          str_split(agi_code, "\\.", simplify = TRUE)[,2])) %>% 
  dplyr::count(gene_id)

#
test5 = ABA_GRN_CORE_TFs %>% 
  mutate(ChIPseq = ifelse((gene_id %in% Ecker_ChIPseq$gene_id), 1, 0),
         DAPseq = ifelse((gene_id %in% Ecker_DAPseq$gene_id), 1, 0),
         TRANSPLANTA_TFs = ifelse((gene_id %in% transplanta_TFs$gene_id), 1, 0)) %>% 
  left_join(transplanta_lines, by = "gene_id") %>% rename("TRANSPLANTA_lines" = n) %>% 
  mutate(TRANSPLANTA_lines = ifelse(is.na(TRANSPLANTA_lines), 0, TRANSPLANTA_lines))

####

test6 = AnnotationDbi::select(org.At.tair.db, 
                              keys = BRC1_dependent_FR$gene_id,
                              columns = c("TAIR", "GOALL"),
                              keytype = "TAIR") %>% 
  filter(GOALL %in% c("GO:0003700")) %>% dplyr::select(c("TAIR","GOALL")) %>% unique %>% 
  rename("gene_id" = TAIR) %>% add_gene_annotation(gene_id_column = "gene_id", tidy_output = FALSE) %>% 
  dplyr::select(c("gene_id", "gene_symbol", "short_description"))

test7 = test6 %>% filter(gene_id %in% BRC1_direct_targets$gene_id |
                           gene_id %in% HB21_direct_targets$gene_id | 
                           gene_id %in% HB40_direct_targets$gene_id | 
                           gene_id %in% HB53_direct_targets$gene_id)
  
```


```{r}
##### Generate target_region to define target genes:
ath_gtf = read_gff("./input/Arabidopsis_thaliana.TAIR10.52.gtf.gz")
ath_genes = ath_gtf %>% filter(type == "gene")
tss = ath_genes %>% resize(width = 1, fix = 'start') %>% select(gene_id) %>% `names<-`(.$gene_id) %>% sort

ext5 = 3000
ext3 = 1000
ath_3kup_1kdown = ath_genes %>% anchor_5p %>% mutate(width = 1) %>% stretch(ext5*2 - 1) %>%
  anchor_5p %>% stretch(ext3-ext5) %>% `mcols<-`(value = list("gene_id" = .$gene_id))

##### Generate peak files for BRC1 and HBs:
# BRC1 peaks (ChIP-seq) "consensus peaks" (peaks that partially overlap in at least two replicates)
qval_filter = -log10(0.05)
peak_max_width = Inf # For now, do not filter peaks by size (waiting on JC Oliveros' MACS2 settings)
peak_min_width = 10

peak_files = list.files(path = "./input/", pattern = "^ChIP\\d_q1_peaks.narrowPeak$", all.files = TRUE, full.names = TRUE)
peak_file_names = str_match(peak_files, "ChIP\\d") %>% as.vector
peak_list = lapply(peak_files, read_narrowpeaks) %>% GRangesList() %>% `names<-`(peak_file_names)

filtered_peak_list = peak_list %>% 
  endoapply(function(x) plyranges::filter(x, qValue > qval_filter)) %>% 
  endoapply(function(x) plyranges::filter(x, (width > peak_min_width) & (width < peak_max_width)))

BRC1_peaks = filtered_peak_list %>% get_consensus_peaks_GRangesList()

# HB peaks (DAP-seq)
peak_files = list.files(path = "./input/", pattern = "^DAP_ATHB\\d{2}_q1_es200_peaks.narrowPeak$", all.files = TRUE, full.names = TRUE)
peak_file_names = str_match(peak_files, "DAP_ATHB\\d{2}") %>% as.vector
peak_list = lapply(peak_files, read_narrowpeaks) %>% GRangesList() %>% `names<-`(peak_file_names)

filtered_peak_list = peak_list %>% 
  endoapply(function(x) plyranges::filter(x, qValue > qval_filter)) %>% 
  endoapply(function(x) plyranges::filter(x, (width > peak_min_width) & (width < peak_max_width)))

HB_peaks = filtered_peak_list %>% endoapply(function(x) plyranges::mutate(x, peak_name = paste0("peak_", rep(1:length(x)))))

##### Generate lists of genes and tidy data.frames:
# BRC1-related gene lists:
BRC1_dependent_FR = fread("./input/BRC1dep_PC2013.txt") %>% 
  rename("gene_id" = Geneid) %>% 
  mutate(gene_id = toupper(gene_id)) %>% 
  mutate(direction = ifelse(logFC > 0, "up", "down"))

BRC1ind_diffexp = brc1ind_results$filtered_tests %>% 
  dplyr::select(c(Geneid, logFC_GFP_BRC1ind_vs_brc1)) %>% 
  rename("gene_id" = Geneid, "logFC" = logFC_GFP_BRC1ind_vs_brc1) %>% 
  mutate(direction = ifelse(logFC > 0, "up", "down")) %>% 
  data.table()

BRC1_direct_targets = get_direct_targets(peak_file = BRC1_peaks,
                                         de_file = BRC1ind_diffexp,
                                         target_region = ath_3kup_1kdown,
                                         gene_id_column_in_de_file = "gene_id",
                                         output = "filtered")

brc1_diffexp = aba_results$list_by_contrast$brc1_ctr_vs_wt_ctr %>% 
  dplyr::select(c(Geneid, logFC_brc1_ctr_vs_wt_ctr)) %>% 
  rename("gene_id" = Geneid, "logFC" = logFC_brc1_ctr_vs_wt_ctr) %>% 
  mutate(direction = ifelse(logFC > 0, "up", "down")) %>% 
  data.table()
# Maybe use brc1_diff_exp without FC threshold?

# HB-related gene lists:
HB21ind_diffexp = hbind_results$list_by_contrast$hb21i_vs_gus %>% 
  dplyr::select(c(Geneid, logFC_hb21i_vs_gus)) %>% 
  rename("gene_id" = Geneid, "logFC" = logFC_hb21i_vs_gus) %>% 
  mutate(direction = ifelse(logFC > 0, "up", "down")) %>% 
  data.table()

HB40ind_diffexp = hbind_results$list_by_contrast$hb40i_vs_gus %>% 
  dplyr::select(c(Geneid, logFC_hb40i_vs_gus)) %>% 
  rename("gene_id" = Geneid, "logFC" = logFC_hb40i_vs_gus) %>% 
  mutate(direction = ifelse(logFC > 0, "up", "down")) %>% 
  data.table()

HB53ind_diffexp = hbind_results$list_by_contrast$hb53i_vs_gus %>% 
  dplyr::select(c(Geneid, logFC_hb53i_vs_gus)) %>% 
  rename("gene_id" = Geneid, "logFC" = logFC_hb53i_vs_gus) %>% 
  mutate(direction = ifelse(logFC > 0, "up", "down")) %>% 
  data.table()

HB21_direct_targets = get_direct_targets(peak_file = hb_peaks$DAP_ATHB21,
                                         de_file = HB21ind_diffexp,
                                         target_region = ath_3kup_1kdown,
                                         gene_id_column_in_de_file = "gene_id",
                                         output = "filtered")

HB40_direct_targets = get_direct_targets(peak_file = hb_peaks$DAP_ATHB40,
                                         de_file = HB40ind_diffexp,
                                         target_region = ath_3kup_1kdown,
                                         gene_id_column_in_de_file = "gene_id",
                                         output = "filtered")

HB53_direct_targets = get_direct_targets(peak_file = hb_peaks$DAP_ATHB53,
                                         de_file = HB53ind_diffexp,
                                         target_region = ath_3kup_1kdown,
                                         gene_id_column_in_de_file = "gene_id",
                                         output = "filtered")

# ABA-related gene lists:
ABA_genes_nemhauser = fread("./input/ABA-responding_genes_Nemhauser2006.txt") %>% mutate(gene_id = toupper(gene_id))

BRC1_dep_ABA_GRN = fread("./input/BRC1-dep_ABA-GRN_PNAS2017.txt") %>% mutate(gene_id = toupper(gene_id))

BRC1_dep_ABA_GRN_CORE = fread("./input/BRC1-dep_ABA-GRN_CORE_PNAS2017.txt")

BRC1_dep_ABA_responding = aba_results$list_by_contrast$wt_aba_vs_wt_ctr %>% 
  dplyr::select(c(Geneid, logFC_wt_aba_vs_wt_ctr)) %>% 
  rename("gene_id" = Geneid, "logFC" = logFC_wt_aba_vs_wt_ctr) %>% 
  mutate(direction = ifelse(logFC > 0, "up", "down")) %>% 
  filter(!gene_id %in% aba_results$list_by_contrast$brc1_aba_vs_brc1_ctr$Geneid) %>% 
  data.table()
# Maybe use BRC1_dep_ABA_responding without FC threshold?

### Check igraph tutorial and build "test" network1
# Use 26 ABA core and add direct target info
expand_matrix = function(m){
  un1 = unique(sort(c(colnames(m), rownames(m))))
  m2 = matrix(0, length(un1), length(un1), dimnames = list(un1, un1))
  m2[row.names(m), colnames(m)] = m
  m2
}

adjm = BRC1_dep_ABA_GRN_CORE %>% bind_rows(setNames("AT3G18550", "gene_id")) %>% 
  mutate(AT3G18550 = ifelse((gene_id %in% BRC1_direct_targets$gene_id), 1, 0),
         AT2G18550 = ifelse((gene_id %in% HB21_direct_targets$gene_id), 1, 0),
         AT4G36740 = ifelse((gene_id %in% HB40_direct_targets$gene_id), 1, 0),
         AT5G66700 = ifelse((gene_id %in% HB53_direct_targets$gene_id), 1, 0)) %>% 
  column_to_rownames("gene_id") %>% as.matrix()

adjm2 = expand_matrix(adjm) %>% t()

g1 = graph_from_adjacency_matrix(adjm2)

# To rearrange network nodes manually and save coordinates:
tkid = tkplot(g1, edge.arrow.size=.4) # plot with tk and save the plot ID number (tkid) to retrieve coordinates

l = tkplot.getcoords(tkid) # grab the coordinates from tkplot

tk_close(tkid, window.close = T) # close tkplot window

plot(g1, layout=l) # re-plot network with tk coordinates

###
adjm3 = BRC1_dep_ABA_GRN_CORE %>% bind_rows(setNames("AT3G18550", "gene_id")) %>% 
  mutate(AT3G18550 = ifelse((gene_id %in% BRC1ind_diffexp$gene_id), 1, 0),
         AT2G18550 = ifelse((gene_id %in% HB21ind_diffexp$gene_id), 1, 0),
         AT4G36740 = ifelse((gene_id %in% HB40ind_diffexp$gene_id), 1, 0),
         AT5G66700 = ifelse((gene_id %in% HB53ind_diffexp$gene_id), 1, 0)) %>% 
  column_to_rownames("gene_id") %>% as.matrix()

adjm4 = expand_matrix(adjm3) %>% t()

g2 = graph_from_adjacency_matrix(adjm4)

plot(g2)
tkplot(g2)

plot(g2,edge.arrow.size=.4)

g2b = simplify(g2, 
               #remove.multiple = F, 
               remove.loops = T) 

plot(g2b,edge.arrow.size=.4)#colnames(adjm) are node names

### TO DO: check how to have two different type of edges and assign attributes
### Generate adj matrix with direct and indirect targets
### Change node names to gene symbol
### Color edges/nodes with up- down- regulation?
### Add node annotation for ABA-responsive ones? Or maybe add ABA as a node?
```



GFP:BRC1 ChIP
```{r}
# Use MACS2-generated peak files with qvalue threshold 1, and then filter "manually"
qval_filter = -log10(0.05)
peak_max_width = 500
peak_min_width = 10

peak_files = list.files(path = "./input/", pattern = "^ChIP\\d_q1_peaks.narrowPeak$", all.files = TRUE, full.names = TRUE)
peak_file_names = str_match(peak_files, "ChIP\\d") %>% as.vector
peak_list = lapply(peak_files, read_narrowpeaks) %>% GRangesList() %>% `names<-`(peak_file_names)

filtered_peak_list = peak_list %>% endoapply(function(x) plyranges::filter(x, qValue > qval_filter)) %>% 
  endoapply(function(x) plyranges::filter(x, (width > peak_min_width) & (width < peak_max_width)))

brc1_peaks = filtered_peak_list %>% get_consensus_peaks_GRangesList()

# Same for DAPseq data
peak_files = list.files(path = "./input/", pattern = "^DAP_ATHB\\d{2}_q1_es200_peaks.narrowPeak$", all.files = TRUE, full.names = TRUE)
peak_file_names = str_match(peak_files, "DAP_ATHB\\d{2}") %>% as.vector
peak_list = lapply(peak_files, read_narrowpeaks) %>% GRangesList() %>% `names<-`(peak_file_names)

filtered_peak_list = peak_list %>% endoapply(function(x) plyranges::filter(x, qValue > qval_filter)) %>% 
  endoapply(function(x) plyranges::filter(x, (width > peak_min_width) & (width < peak_max_width)))

hb_peaks = filtered_peak_list %>% endoapply(function(x) plyranges::mutate(x, peak_name = paste0("peak_", rep(1:length(x)))))

test = c(GRangesList(BRC1_peaks = brc1_peaks), hb_peaks)

test2 = endoapply(test, function(x) {plyranges::select(x, peak_name)})

helper_func = function(x) {plyranges::mutate(x, peak_value = rep(1,length(x)))}

test3 = endoapply(test2, helper_func)

# Plot peak location respective of TSS. With "heatmap"
# Create GRanges object with all arabidopsis genes from ensembl .gtf file
ath_gtf = read_gff("./input/Arabidopsis_thaliana.TAIR10.52.gtf.gz")
ath_genes = ath_gtf %>% filter(type == "gene")
tss = ath_genes %>% resize(width=1, fix='start') %>% select(gene_id) %>% `names<-`(.$gene_id) %>% sort

#### Why scale is not the same as when done for hb_peaks only? 
example = batch_enrichedheatmaps(test3[2:3], 
                                 tss = tss,
                                 value_column = "peak_value",
                                 anno_color = "black", 
                                 show_heatmap_legend = TRUE) 


example2 = batch_enrichedheatmaps(test3[1], 
                                  tss = tss,
                                  value_column = "peak_value",
                                  anno_color = "black", 
                                  show_heatmap_legend = TRUE) 

###
example + example2
example2 + example

############# CODE IN PROGRESS 
figure_filename = paste0("./output/BRC1_HBs_peak_location.png")

png(figure_filename, width = 30, height = 15, units = "cm", res = 300)
draw(example, 
     ht_gap = unit(1, "cm"),
     padding = unit(c(0, 0.5, 0, 0.02), "cm"))
dev.off()

# Example 2. Plot HB Dapseq data relative to TSS ####
peak_files = list.files(path = "./input/dapseq_data/", pattern = "*.narrowPeak", all.files = TRUE,
                        full.names = TRUE) %>% str_extract(".*HB_ATHB21.*|.*HB_ATHB40.*|.*HB_ATHB53.*") %>% as.vector %>% discard(is.na)

peak_file_names = c("HB21","HB21_amp","HB40","HB40_amp","HB53","HB53_amp")
peak_list = lapply(peak_files, read_narrowpeaks) %>% GRangesList() %>% `names<-`(peak_file_names) %>% `seqlevelsStyle<-`(seqlevelsStyle(tss))

dapseq_htlist = batch_enrichedheatmaps(peak_list,
                                       tss = tss,
                                       anno_color = "black",
                                       #value_column = "signalValue",
                                       #heatmap_col_breaks = c(0,0.99),
                                       show_heatmap_legend = TRUE)

ext5 = 3000
ext3 = 1000
figure_filename = paste0("./output/HB_peak_location_",ext5,"_",ext3,".png")

png(figure_filename, width = 30, height = 15, units = "cm", res = 300)
draw(dapseq_htlist, 
     ht_gap = unit(1, "cm"),
     padding = unit(c(0, 0.5, 0, 0.02), "cm"))
dev.off()



# Select genes with peak in their 3kb_up+1kb_dn of TSS ####
# Retrieve 3kb upstream and 1kb downstream of TSS (using plyranges)
ext5 = 3000
ext3 = 1000
ath_3kup_1kdown = ath_genes %>% anchor_5p %>% mutate(width = 1) %>% stretch(ext5*2 - 1) %>%
  anchor_5p %>% stretch(ext3-ext5) %>% `mcols<-`(value = list("gene_id" = .$gene_id))

write_bed(ath_3kup_1kdown, "./output/test_bed_5k_2k.bed")

#####
# TO DO Make function to generate annotation_df from list of direct targets
hb_peak_list = peak_list[c(1,3,5)]
hb_de_list = hbind_results$list_by_contrast

test = make_anno_df(hb_de_list,hb_peak_list,
                    target_region = ath_3kup_1kdown,
                    peak_name_column = "name")


brc1_de_list = brc1ind_results$list_by_contrast
brc1_peaks = GRangesList(macs2_consensus_q005,macs2_consensus_q001,macs2_consensus_q0001) %>% `names<-`(c("q0.05","q0.01","q.0.001"))

brc1_dt = get_direct_targets(brc1_peaks$q0.05,brc1_de_list[[1]],target_region = ath_3kup_1kdown)

brc1_de_direct_targets = brc1_de_list[[1]] %>% filter(Geneid %in% brc1_dt)

##### 
test = make_anno_df(brc1_de_direct_targets,hb_peak_list,
                    target_region = ath_3kup_1kdown,
                    peak_name_column = "name")

test2 = make_anno_df(brc1_de_direct_targets,brc1_peaks,
                     target_region = ath_3kup_1kdown,
                     peak_name_column = "peak_name",
                     gene_id_column = "Geneid")


x = get_direct_targets(brc1_peaks[[1]], de_file=brc1_de_direct_targets, target_region = ath_3kup_1kdown)

anno_df = cbind(test2,test)

# heatmap
input = brc1_de_direct_targets %>% select(c(Geneid, logFC_GFP_BRC1ind_vs_brc1)) %>% left_join(HBind_data, by =
                                                                                                "Geneid") %>%
  left_join(aba_data, by = "Geneid") %>%
  select(
    c(
      Geneid,
      logFC_GFP_BRC1ind_vs_brc1,
      logFC_brc1_ctr_vs_wt_ctr,
      logFC_wt_aba_vs_wt_ctr,
      logFC_hb21i_vs_gus,
      logFC_hb40i_vs_gus,
      logFC_hb53i_vs_gus
    )
  ) 

# input = HBind_data %>% 
#   select(c(Geneid,logFC_hb21i_vs_gus,logFC_hb40i_vs_gus,logFC_hb53i_vs_gus)) 
# input = input %>%
#   filter(Geneid %in% brc1_de$Geneid)
# 

brc1_de = aba_data_unfiltered %>% filter(FDR_brc1_ctr_vs_wt_ctr<0.05)
brc1_de_anno = ifelse(input$Geneid %in% brc1_de$Geneid, 1,0) %>% `names<-`(input$Geneid)

brc1_array = read.table("./input/BRC1dep_PC2013.txt",header = TRUE) %>% mutate(Geneid = toupper(Geneid))
brc1_array_anno = ifelse(input$Geneid %in% brc1_array$Geneid, 1,0) %>% `names<-`(input$Geneid)

# Create list of coloring functions for annotation dataframe
anno_col_fun = colorRamp2(c(0, 1), c("white", "black")) 

col_fun_list = list()
for(i in colnames(anno_df)){
  col_fun_list[[i]] = anno_col_fun
}

ha = HeatmapAnnotation(df = anno_df,
                       which = "row",
                       # annotation_label = c("brc1 de","brc1 array","BRC1 csaw","BRC1 q005", "BRC1 q001", "BRC1 q0001",
                       #                      "HB21 Dapseq","HB40 Dapseq","HB53 Dapseq"),
                       annotation_name_side="top",
                       annotation_name_rot=45,
                       show_legend = FALSE,
                       col = col_fun_list)


ht_input = input %>% column_to_rownames("Geneid") %>% as.matrix()

Heatmap(ht_input[,-(2:3)],
        clustering_method_rows = "ward.D2",
        right_annotation = ha,
        show_row_names = FALSE,
        #show_column_names = FALSE
)

Heatmap(ht_input[,c(1,4:6)],
        clustering_method_rows = "ward.D2",
        right_annotation = ha,
        show_row_names = FALSE,
        #show_column_names = FALSE
)

Heatmap(ht_input[,c(1)],
        clustering_method_rows = "ward.D2",
        right_annotation = ha,
        show_row_names = FALSE,
        #show_column_names = FALSE
)
```




GO enrichment, GSEA and KEGG enrichment
```{r}
### GO enrichment and GSEA 

# Generate GO object with Information Content for Semantic Similarity analyses
if(!exists("athGO")){
  athGO = godata("org.At.tair.db", ont="BP")
}

# Object to find GO common ancestor
GO_anc = as.list(GOBPANCESTOR)

# Object to match GO ID with GO definitions
GO_def = suppressMessages(AnnotationDbi::select(GO.db,
                                                keys=(keys(GO.db)),
                                                columns=c("GOID","TERM","DEFINITION"),
                                                keytype="GOID"))

# Format input data for GO and GSEA analyses (vector of Fold-change named with gene IDs)
input_data = brc1ind_results$list_by_contrast[[1]]
fc_column = colnames(input_data)[grepl(c("^logFC"),colnames(input_data))] 
GO_input = input_data %>% dplyr::select(Geneid, all_of(fc_column))


ranked_genes = setNames(GO_input[,fc_column],
                        GO_input$Geneid) %>% sort %>% rev

genes_up = ranked_genes[ranked_genes > 0]
genes_dn = ranked_genes[ranked_genes < 0]

# Perform GO enrichment analysis with up- and down-regulated genes
GOenrich_up = enrichGO(gene = names(genes_up),
                       OrgDb = org.At.tair.db,
                       keyType = "TAIR",
                       ont = "BP",
                       pAdjustMethod = "BH",
                       qvalueCutoff = 0.05)
GOenrich_up %>% as.data.frame() %>% pull(ID) %>% length()

goplot(GOenrich_up)

GOenrich_dn = enrichGO(gene = names(genes_dn),
                       OrgDb = org.At.tair.db,
                       keyType = "TAIR",
                       ont = "BP",
                       pAdjustMethod = "BH",
                       qvalueCutoff = 0.05)

goplot(GOenrich_dn)

#####
heatmap1 = simplify_go(GOenrich_up,
                       GO_sem_sim = athGO,
                       GO_def = GO_def)
heatmap2 = simplify_go(GOenrich_dn,
                       GO_sem_sim = athGO,
                       GO_def = GO_def)

#####
GO_data = as.data.frame(GOenrich_up) # to query for GO IDs and descriptions

go_id = GO_data %>% pull(unique(ID))

ss_rel = mgoSim(go_id, go_id, semData=athGO, measure="Rel", combine=NULL)

test = simplifyGO(ss_rel, plot = T)

# Calculate optimal cluster number "mathematically"
#### WeighedCluster
GO_hclust = (1 - ss_rel) %>% as.dist %>%
  hclust(method = "ward.D2")

GO_hclust_n = length(GO_hclust$order)

clustrange = as.clustrange(GO_hclust, diss = (1 - ss_rel), ncluster = GO_hclust_n)
pamRange = wcKMedRange((1 - ss_rel), kvals = 2:GO_hclust_n)

# par(mfrow=c(1,2))
# plot(clustrange,
#      stat=c("PBC","ASWw", "ASW","HG", "HGSD", "RHC"),
#      norm="zscore",lwd=3)
# plot(pamRange,
#      stat=c("PBC","ASWw", "ASW","HG", "HGSD", "RHC"),
#      norm="zscore",lwd=3)

crange_pbc = clustrange$stats$PBC
prange_pbc = pamRange$stats$PBC

max_crange_pbc = find_local_max(crange_pbc)
max_prange_pbc = find_local_max(prange_pbc)

max1_crange_pbc = which.max(crange_pbc)
max1_prange_pbc = which.max(prange_pbc)

##### Figure to check different GO cluster numbers (currently using clustrange)
go_id = GOenrich_dn %>% get_goids

test4 = check_go_clustering(go_id)

test_list = list()
for(i in seq_along(test4)){
  test_list[[i]] = grid.grabExpr(draw(test4[[i]]))
}

figure = ggarrange(plotlist = test_list)

figure

figure_filename = paste0("./output/test_check_cluster.png")

png(figure_filename, width = 33, height = 15, units = "cm", res = 300)
figure
dev.off()
```


Quantify ChIP "strength" (csaw)
```{r}
# Used three qvalue threshold to call peaks in MACS2 (qval < 0.05, 0.01 or 0.001)
# Consensus with MACS2 qval < 0.001
peak_file_list = list.files(path = "./input/", pattern="^BRC1_ChIP.*q0001.*\\.narrowPeak$", full.names=TRUE)
peak_names = peak_file_list %>% str_extract("BRC1_ChIP*.")

macs2_consensus_q0001 = get_consensus_peaks(peak_file_list, peak_names)
write_bed(macs2_consensus_q0001, file = "./output/macs2_q0001_consensus.bed")

# Consensus with MACS2 qval < 0.01
peak_file_list = list.files(path = "./input/", pattern="^BRC1_ChIP.*q001.*\\.narrowPeak$", full.names=TRUE)
peak_names = peak_file_list %>% str_extract("BRC1_ChIP*.")

macs2_consensus_q001 = get_consensus_peaks(peak_file_list,peak_names)
write_bed(macs2_consensus_q001, file = "./output/macs2_q001_consensus.bed")

# Consensus with MACS2 qval < 0.05
peak_file_list = list.files(path = "./input/", pattern="^BRC1_ChIP.*q0\\.05.*\\.narrowPeak$", full.names=TRUE)
peak_names = peak_file_list %>% str_extract("BRC1_ChIP*.")

macs2_consensus_q005 = get_consensus_peaks(peak_file_list,peak_names)
write_bed(macs2_consensus_q005, file = "./output/macs2_q005_consensus.bed")

#####
# csaw to quantify peak strength (TO DO: CLEAN CODE)

# 1- Check fragment length to precisely quantify peak signal (calculate cross-correlation coefficient (ccf)) ####
# "For weak signal datasets, the read-length peak will start to dominate."
# https://hbctraining.github.io/Intro-to-ChIPseq/lessons/06_combine_chipQC_and_metrics.html
bam_files = list.files(path = "D:/PERSONAL_SACO/Cubas lab/BRC1 ChIPseq/sam_output/", pattern=".*\\.bam$", full.names=TRUE)
bam_files = bam_files[c(4:6,1:3)] # reorder columns so controls are first
bam_filenames = bam_files %>% str_match("ChIP\\d|Input\\d") %>% as.vector

# Load csaw Parameters and turn on removal of duplicate reads (use param=dedup.on as param object for cross-correlation studies)
param = readParam()
dedup.on = initialize(param, dedup=TRUE)

# Calculate cross-correlation for each .bam file and make dataframe for plotting with labels for max ccf for each file
ccf_list = lapply(bam_files, correlateReads, param=dedup.on) %>% `names<-`(bam_filenames)

ccf_list_plot = as.data.frame(do.call(cbind, ccf_list)) %>% 
  rownames_to_column("bp") %>% mutate (bp = as.numeric(bp)) %>% 
  pivot_longer(-bp,names_to = "sample",values_to = "ccf")

ccf_labels = sapply(ccf_list, maximizeCcf, ignore=100) %>% as.data.frame %>% rownames_to_column %>% setNames(c("sample","max_ccf"))

# Calculate average correlation profile across all the IP bam files
ccf_total = bam_files[4:6] %>% correlateReads(param=dedup.on)
max_total_ccf = maximizeCcf(ccf_total, ignore=100)

# Plot ccf per file
ggplot(ccf_list_plot, aes(x = bp, y = ccf, group = sample)) +
  geom_line() +
  geom_vline(aes(xintercept = max_ccf), ccf_labels) +
  geom_label(inherit.aes = FALSE, data = ccf_labels, 
             aes(label = paste0("Max ccf (>100 bp): ",max_ccf)), label.size = NA, alpha = 0.5,
             x = -Inf, y = Inf,
             hjust = 0, vjust = 1) +
  coord_cartesian(xlim = c(0,300)) +
  scale_x_continuous(expand = expansion(mult = c(0,0.05))) +
  facet_wrap(~sample)


# 2- Count peak signal using common ccf ####
data = windowCounts(bam_files, ext=max_total_ccf, width=10, spacing=10)

# Remove "unintersting regions" (regions withour peaks)
binned = windowCounts(bam_files, bin=TRUE, width=10000)
keep = filterWindowsGlobal(data, binned)$filter > log2(2)
data2 = data[keep,]

data2 = normFactors(binned, se.out=data2)

# Create DGEList object to quantify peak signal
sample_names = bam_filenames
sample_groups = gsub('.{1}$', '', sample_names) %>% factor(levels=unique(gsub('.{1}$', '', sample_names)))
design = model.matrix(~sample_groups)

DGEL = asDGEList(data2, group = sample_groups)
rownames(DGEL$samples) = sample_names

DGEL = estimateDisp(DGEL, design)
fit = glmQLFit(DGEL, design, robust=TRUE)
results = glmQLFTest(fit)

merged = mergeResults(data2, results$table, tol=200L) # merge peaks closer than 200 bp

# Filter results for significance (FDR), size > 10 bp, score > 0 (enriched in IP)
is.sig = merged$combined$FDR <= 0.05
csaw_result = merged$regions[is.sig]
csaw_result$score = merged$combined$rep.logFC[is.sig]
csaw_result$peak_width = width(csaw_result)
csaw_result = csaw_result %>% filter((score > 0) & (peak_width > 10))
names(csaw_result) = paste0("region_", 1:length(csaw_result))

export(csaw_result, "./output/test_csaw.bed")

# 2b - csaw with good replicates
bam_files2 = bam_files[-c(1,4)]
bam_filenames2 = bam_filenames[-c(1,4)]

data = windowCounts(bam_files2, ext=max_total_ccf, width=10, spacing=10)

# remove "unintersting regions"
binned = windowCounts(bam_files2, bin=TRUE, width=10000)
keep = filterWindowsGlobal(data, binned)$filter > log2(2)
data2 = data[keep,]

data2 = normFactors(binned, se.out=data2)

# Create DGEList object
sample_names = bam_filenames2
sample_groups = gsub('.{1}$', '', sample_names) %>% factor(levels=unique(gsub('.{1}$', '', sample_names)))
design = model.matrix(~sample_groups)

DGEL = asDGEList(data2, group = sample_groups)
rownames(DGEL$samples) = sample_names

DGEL = estimateDisp(DGEL, design)
fit = glmQLFit(DGEL, design, robust=TRUE)
results = glmQLFTest(fit)

merged = mergeResults(data2, results$table, tol=200L) # merge peaks closer than 200 bp

# Filter results for significance (FDR), size > 10 bp, score > 0 (enriched in IP)
is.sig = merged$combined$FDR <= 0.05
csaw_result = merged$regions[is.sig]
csaw_result$score = merged$combined$rep.logFC[is.sig]
csaw_result$peak_width = width(csaw_result)
csaw_result = csaw_result %>% filter((score > 0) & (peak_width > 10))
names(csaw_result) = paste0("region_", 1:length(csaw_result))

export(csaw_result, "./output/test_csaw_rep1_2.bed")

```



To check number of peaks depending on qvalue filter for MACS2 narrowPeak files with
```{r}
macs_q1_files = list.files(path = "./input/gema/peaks/macs2_ChIP/", pattern = "\\.narrowPeak$", full.names = TRUE)

dapseq_files = list.files(path = "./input/gema/peaks/macs2_DAP/", pattern = "\\.narrowPeak$", full.names = TRUE)

peak_names = c("ChIP2","ChIP3","ChIP7")

peak_names = c("HB21", "HB40", "HB53")
macs_q1 = lapply(dapseq_files, read_narrowpeaks) %>% `names<-`(peak_names)

qvals = -log10(c(0.1,0.05,0.01,0.001))

tmp_func = function(x,y) { plyranges::filter(x, qValue > y) %>% length }

a = list()
for(q in qvals){
  q_val = 10^-q %>% paste0("qval_",.)
  a[[q_val]] = sapply(macs_q1, tmp_func, q)
}

tmp_func2 = function(x,y) { 
  plyranges::filter(x, qValue > y)
}

b = list()
for(q in qvals){
  q_val = 10^-q %>% paste0("qval_",.)
  test = sapply(macs_q1, tmp_func2, q)
  z = get_consensus_peaks_GRangesList(test,peak_names)
  b[q_val] = (length(z))
}

as.data.frame(a) %>% rbind("Consensus" = b)
```

(to do) Compare BRC1dep
```{r}
BRC1dep_PC2013 = fread("./input/BRC1dep_PC2013.txt") %>% mutate(Geneid = toupper(Geneid))
BRC1dep_PC2013$logFC %>% hist(breaks = 100)

# To do: compare microarray results to RNAseq
```

(to do) BRC1 network
```{r}
macs2_consensus_q0001
macs2_consensus_q001
macs2_consensus_q005
ath_3kup_1kdown

ABA_results
HBind_results
GFPBRC1ind_results


###
test = ABA_results %>% select(c(Geneid,logFC_brc1_ctr_vs_wt_ctr,FDR_brc1_ctr_vs_wt_ctr,logFC_tri_ctr_vs_wt_ctr,FDR_tri_ctr_vs_wt_ctr)) %>% 
  filter(FDR_brc1_ctr_vs_wt_ctr < 0.05)

#### BUILD MATRIX FOR HEATMAP
data = GFPBRC1ind_results
gene_symbol = suppressMessages(mapIds(org.At.tair.db,
                                      column = "SYMBOL",
                                      keys = data$Geneid,
                                      keytype = "TAIR",
                                      multiVals = "first"))

mat_row_labels = apply(cbind(data$Geneid, gene_symbol), 1, 
                       function(x) paste(x[!is.na(x)], collapse = " "))

logfc_column = "logFC_GFP_BRC1ind_vs_brc1"

filtered_data = data %>% dplyr::select(all_of(logfc_column)) %>% 
  arrange(desc(get(logfc_column))) %>% 
  as.matrix %>% `rownames<-`(mat_row_labels) %>% `colnames<-`(c("GFPBRC1ind"))

Heatmap(filtered_data,
        #clustering_method_rows = "ward.D2",
        #clustering_method_columns = "ward.D2",
        row_order = rownames(filtered_data),
        row_names_gp = gpar(fontsize = 4))


```

(to do) GO, Upset plots
```{r}
##### 
# IN PROGRESS:
### GO enrichment and GSEA 

# Generate GO object with Information Content for Semantic Similarity analyses
if(!exists("athGO")){
  athGO = godata("org.At.tair.db", ont="BP")
}

# Object to match GO ID with GO definitions
GO_def = AnnotationDbi::select(GO.db,
                               keys=(keys(GO.db)),
                               columns=c("GOID","TERM","DEFINITION"),
                               keytype="GOID")

# Object to find GO common ancestor
GO_anc = as.list(GOBPANCESTOR)

# Object to match GO ID with GO definitions
GO_def = AnnotationDbi::select(GO.db,
                               keys=(keys(GO.db)),
                               columns=c("GOID","TERM","DEFINITION"),
                               keytype="GOID")

# Format input data for GO and GSEA analyses (vector of Fold-change named with gene IDs)
fc_column = colnames(filtered_tests_output)[grepl(c("^logFC"),colnames(filtered_tests_output))] 
GO_input = filtered_tests_output %>% dplyr::select(Geneid, all_of(fc_column))

ranked_genes = setNames(GO_input[,fc_column],
                        GO_input$Geneid) %>% sort %>% rev

genes_up = ranked_genes[ranked_genes > 0]
genes_dn = ranked_genes[ranked_genes < 0]

# Perform GO enrichment analysis with up- and down-regulated genes
GOenrich_up = enrichGO(gene = names(genes_up),
                       OrgDb = org.At.tair.db,
                       keyType = "TAIR",
                       ont = "BP",
                       pAdjustMethod = "BH",
                       qvalueCutoff = 0.05)
GOenrich_up %>% as.data.frame() %>% pull(ID) %>% length()

goplot(GOenrich_up)

GOenrich_dn = enrichGO(gene = names(genes_dn),
                       OrgDb = org.At.tair.db,
                       keyType = "TAIR",
                       ont = "BP",
                       pAdjustMethod = "BH",
                       qvalueCutoff = 0.05)

goplot(GOenrich_dn)

#####
# Clustering of GO enriched terms
# Generate object with GO Semantic Similarity and Information Content


# 3- Summarize GO by semantic similarity
# Get common GO terms and calculate semantic similarity between them
GO_data = as.data.frame(GOenrich_dn) # to query for GO IDs and descriptions

GO_IDs = GO_data %>% pull(unique(ID))
ss_rel = mgoSim(GO_IDs, GO_IDs, semData=athGO, measure="Rel", combine=NULL)

# Calculate optimal cluster number "mathematically"
#### WeighedCluster
GO_hclust = (1 - ss_rel) %>% as.dist %>%
  hclust(method = "ward.D2")

GO_hclust_n = length(GO_hclust$order)

clustrange = as.clustrange(GO_hclust, diss=(1 - ss_rel), ncluster = GO_hclust_n)

# R2 and R2-sq will always give maximum number of clusters as optimal (see WeighedCluster user's guide)
# RHC is reverse HC, so max value is ideal
clustrange_summary = summary(clustrange, max.rank=1) %>% rownames_to_column("method") %>% filter(!(method %in% c("R2","R2sq"))) 

best_cluster = clustrange_summary$`1. N groups` %>% mode_value()

best_cluster

plot(clustrange, 
     stat=c("PBC","ASWw", "ASW","HG", "HGSD", "RHC"), 
     norm="zscore",lwd=3)

pamRange <- wcKMedRange((1 - ss_rel), kvals=2:GO_hclust_n)
pamrange_summary = summary(pamRange, max.rank=2)
best_cluster_pam = pamrange_summary$`1. N groups` %>% mode_value()

best_cluster_pam

plot(pamRange, 
     stat=c("PBC","ASWw", "ASW","HG", "HGSD", "RHC"), 
     norm="zscore",lwd=3)
####
which.peaks <- function(x,partial=TRUE,decreasing=FALSE){
  if (decreasing){
    if (partial){
      which(diff(c(FALSE,diff(x)>0,TRUE))>0)
    }else {
      which(diff(diff(x)>0)>0)+1
    }
  }else {
    if (partial){
      which(diff(c(TRUE,diff(x)>=0,FALSE))<0)
    }else {
      which(diff(diff(x)>=0)<0)+1
    }
  }
}

test = pamRange$stats$PBC

which.peaks(test)
sapply(pamRange$stats, which.peaks)

###
# Visualize GO similarity
row_labs = structure(paste(GO_IDs,GO_data$Description), names = paste0(GO_IDs))
col_fun = colorRamp2(c(0,1), c("white", "red"))

test = structure(GO_data$p.adjust, names = paste0(GO_IDs))
pvalue_col_fun = colorRamp2(c(0, 0.05), c("green", "white")) 

ha = HeatmapAnnotation(pvalue = test,
                       which = "row", 
                       annotation_label = "adj. p-val.",
                       annotation_name_side="top",
                       annotation_name_rot=45,
                       col = list(pvalue = pvalue_col_fun),
                       annotation_legend_param = list(
                         pvalue = list(
                           at = c(0, 0.05))))

GO_heatmap = Heatmap(ss_rel,
                     name = "Similarity",
                     clustering_method_rows = "ward.D2",
                     clustering_method_columns = "ward.D2",
                     col = col_fun,
                     row_labels = row_labs[rownames(ss_rel)],
                     row_names_max_width = max_text_width(row_labs),
                     right_annotation = ha,
                     show_column_names = FALSE
)

GO_heatmap

# Visualize GO clustering
dd = (1 - ss_rel) %>% as.dist %>%
  hclust(method = "ward.D2") %>% as.dendrogram(hang = -1) %>%
  set("labels_cex", 0.6)

labels(dd) = GO_data$Description[match(labels(dd), GO_data$ID)]

par(mar = c(1, 1, 1, 20),
    xpd = NA)
plot(dd, horiz = T)


# In this case, upon visual inspection (GO_heatmap) we see three clusters. Replot with colors to visualize
cluster_number = 15
div_pal = distinctColorPalette(cluster_number)

clusters = cutree(dd, cluster_number,order_clusters_as_data=T) %>% 
  as.factor() %>% fct_inorder() %>% fct_rev()

dd = (1 - ss_rel) %>% as.dist %>%
  hclust(method = "ward.D2") %>% as.dendrogram(hang = -1) %>%
  set("labels_cex", 0.6) %>% 
  set("branches_k_color", k=cluster_number, value = div_pal) %>% 
  set("labels_col", k=cluster_number, value = div_pal)

labels(dd) = GO_data$Description[match(labels(dd), GO_data$ID)]

par(mar = c(1, 1, 1, 20),
    xpd = NA,
    bg = "grey50"
) 
plot(dd, horiz = T)

# 4- Select representative term for each cluster
# Retrieve Information Content for each term
tmp = GO_data %>% 
  mutate(Cluster = factor(clusters[match(Description, names(clusters))])) %>%
  dplyr::select(c("ID","Description","Cluster")) %>% mutate(IC = athGO@IC[ID])

# Retrieve ancestral GO terms
tmp2 = GO_anc[tmp$ID] %>% stack() %>% 
  mutate(CL = tmp$Cluster[match(ind,tmp$ID)]) %>% 
  data.table()

# Obtain representative ancestral GO term by IC^2 (if there is a tie it will return only one term)
reprGO = tmp2[,.N,by=c("CL","values")] %>% 
  mutate(IC = athGO@IC[values]) %>% 
  mutate(importance = (IC^2)) %>% group_by(CL) %>% 
  dplyr::slice(which.max(importance)) %>% 
  #dplyr::filter(importance == max(importance,na.rm=T)) %>%
  ungroup() %>% mutate(Desc = GO_def$TERM[match(values,GO_def$GOID)])

reprGO


####




# KEGG enrichment 
# search_kegg_organism('ath', by='kegg_code')

# To do, merge up and down regulated pathways for plotting together
KEG_enrich_up = enrichKEGG(gene         = names(genes_up),
                           organism     = "ath",
                           pvalueCutoff = 0.05)

KEG_enrich_dn = enrichKEGG(gene         = genes_dn$Geneid,
                           organism     = "ath",
                           pvalueCutoff = 0.05)

KEGG_ids = KEG_enrich_up %>% as.data.frame() %>% pull(ID)
KEGG_ids2 = KEG_enrich_dn %>% as.data.frame() %>% pull(ID)

#browseKEGG(KEG_enrich_up, KEGG_ids[1])

pathview(gene.data  = genes_up,
         pathway.id = KEGG_ids[1],
         species    = "ath",
         gene.idtype = "TAIR",
         gene.annotpkg = "org.At.tair.db",
         limit      = list(gene=max(abs(genes_up)), cpd=1))

#####
# Upset plot to see overlap
# filtered_data = filtered_tests_output %>% 
#   dplyr::select(logFC_gus_vs_hb21i,logFC_gus_vs_hb40i,logFC_gus_vs_hb53i) %>% 
#   `colnames<-`(c("HB21ind","HB40ind","HB53ind"))
# 
# HB21up = filtered_data %>% filter(HB21ind > 1) %>% rownames %>% list %>% `names<-`(paste0("HB21ind up (",length(unlist(.)),")"))
# HB21dn = filtered_data %>% filter(HB21ind < -1) %>% rownames %>% list %>% `names<-`(paste0("HB21ind down   (",length(unlist(.)),")"))
# HB40up = filtered_data %>% filter(HB40ind > 1) %>% rownames %>% list %>% `names<-`(paste0("HB40ind up   (",length(unlist(.)),")"))
# HB40dn = filtered_data %>% filter(HB40ind < -1) %>% rownames %>% list %>% `names<-`(paste0("HB40ind down   (",length(unlist(.)),")"))
# HB53up = filtered_data %>% filter(HB53ind > 1) %>% rownames %>% list %>% `names<-`(paste0("HB53ind up   (",length(unlist(.)),")"))
# HB53dn = filtered_data %>% filter(HB53ind < -1) %>% rownames %>% list %>% `names<-`(paste0("HB53ind down   (",length(unlist(.)),")"))
# 
# listInput = c(HB21up,HB40up,HB53up,HB21dn,HB40dn,HB53dn)
# 
# ggupset_input = list_to_matrix(listInput) %>% as.data.frame %>%
#   rownames_to_column("GeneID") %>%
#   gather(-GeneID, key = "sample", value = "value") %>% 
#   filter(value == 1) %>% 
#   dplyr::select(-value) %>% 
#   group_by(GeneID) %>%
#   summarize(sample = list(sample), .groups = "drop_last")
# 
# ###UpSet plot:
# UPSET_plot = ggplot(ggupset_input, aes(x=sample)) +
#   geom_bar() +
#   scale_y_continuous("Number of\nGenes", expand = expansion(mult = c(0, .25))) +
#   geom_text(stat = "count",
#             aes(label=..count..),
#             hjust = -.1, 
#             size = 2,
#             angle = 90) +
#   scale_x_upset(name = "", order_by = "freq", 
#                 sets = c(names(listInput)),
#                 n_intersections = 14) +
#   theme_classic() +
#   theme(axis.text.x = element_text(color="black"), 
#         axis.text.y = element_text(color="black"),
#         axis.ticks = element_line(color="black"),
#         plot.margin = unit(c(5.5,5.5,5.5,53), "pt"))
# # Heatmap with significant genes:
# 
# 
# mat = all_vs_ctr[,7:9]
# 
# Heatmap(mat)

```

# Extra code
```{r}
# ###
# test = cutree(GO_hclust, k = max_crange_pbc)
# 
# repr_GO = GO_anc[go_id] %>% stack() %>% `colnames<-`(c("ancestral", "go_id")) %>% 
#   left_join(dplyr::select(df, c("cluster", "id")), by = setNames("id", "go_id")) %>% 
#   group_by(cluster, ancestral) %>% add_count() %>% ungroup %>% 
#   mutate(IC = GO_semsim@IC[ancestral]) %>% 
#   mutate(importance = (n*IC^2)) %>% 
#   group_by(cluster) %>% 
#   dplyr::slice(which.max(importance)) %>% 
#   left_join(dplyr::select(GO_def, c("GOID","TERM")), by = setNames("GOID", "ancestral")) %>% 
#   dplyr::select(c("ancestral","cluster","importance","TERM"))
# 
# set.seed(1)
# test2 = as.data.frame(test) %>% mutate_if(is.integer, as.factor)
# 
# col_list = lapply(test2, function(x) {set.seed(1)
#   distinctColorPalette(k = length(levels(x)))})
# 
# col_list_vector = mapply(setNames, col_list, lapply(test2,levels))
# 
# 
# 
# custom_colors = setNames(col_vector, levels(anno_df$anc_term))
# 
# # Heatmap parameters (annotation, row labels, color function for matrix)
# ha = HeatmapAnnotation(df = as.data.frame(test),
#                        which = "row",
#                        annotation_label = "GO Cluster",
#                        show_annotation_name = FALSE,
#                        col = col_list_vector)
# 
# row_labs = structure(paste(go_id, GO_data$Description), names = paste0(go_id))
# col_fun = colorRamp2(c(0,1), c("white", "red"))
# 
# # Generate Heatmap
# term_order = unlist(lapply(levels(test2$`12`), function(le) {
#   l = test2$`12` == le
#   if(sum(l) <= 1) {
#     return(which(l))
#   } else {
#     mm = ss_rel[l, l, drop = FALSE]
#     which(l)[hclust(stats::dist(mm))$order]
#   }
# }))
#   
# 
# 
# GO_heatmap = Heatmap(ss_rel,
#                      name = "Similarity",
#                      #clustering_method_columns = "ward.D2",
#                      #clustering_method_rows = "ward.D2",
#                      row_order = term_order, column_order = term_order,
#                      col = col_fun,
#                      row_labels = row_labs[rownames(ss_rel)],
#                      row_names_max_width = max_text_width(row_labs),
#                      right_annotation = ha,
#                      show_column_names = FALSE)
# GO_heatmap
# 



# # Calculate optimal cluster number with WeighedCluster
#   GO_hclust = (1 - ss_rel) %>% as.dist %>%
#     hclust(method = clust_method)
#   
#   GO_hclust_n = length(GO_hclust$order)
#   
#   clustrange = WeightedCluster::as.clustrange(GO_hclust, diss=(1 - ss_rel), ncluster = GO_hclust_n)
# 
#   clustrange_plot = plot(clustrange, 
#                          stat=c("PBC","ASWw", "ASW","HG", "HGSD", "RHC"), 
#                          norm="zscore",lwd=3)
#   
#   pamRange = WeightedCluster::wcKMedRange((1 - ss_rel), kvals=2:GO_hclust_n)
# 
#   pamrange_plot = plot(pamRange, 
#                        stat=c("PBC","ASWw", "ASW","HG", "HGSD", "RHC"), 
#                        norm="zscore",lwd=3)
#   
#   par(mfrow=c(1,2))
#   plot(clustrange, 
#        stat=c("PBC","ASWw", "ASW","HG", "HGSD", "RHC"), 
#        norm="zscore",lwd=3)
#   plot(pamRange, 
#        stat=c("PBC","ASWw", "ASW","HG", "HGSD", "RHC"), 
#        norm="zscore",lwd=3)
#   
#   test = clustrange$stats$PBC
#   test2 = pamRange$stats$PBC
#   
#   clust_range_max = find_local_max(clustrange$stats$PBC) %>% .[.!=1] # remove 1 if its a max value
#   pam_range_max = find_local_max(pamRange$stats$PBC) %>% .[.!=1] # remove 1 if its a max value
#   
#   return(list("clust_range_max" = clust_range_max,
#               "pam_range_max" = pam_range_max))
#   ### To do, cluster GOs based on find_local_max
#   ### Make EXTERNAL function to retrieve representative GOs from GOenrich object for different partitions (and then apply it for each partition)
#   ### Make annotation for different partitions for Heatmap and plot diss_matrix with legends to see partitions
#   cluster_number = 7
#   
#   hc = (1 - ss_rel) %>% as.dist %>%
#     hclust(method = "ward.D2")
#   
#   anno_df = mapply(cutree, k = clust_range_max, 
#                    MoreArgs = list(tree = hc), 
#                    SIMPLIFY = FALSE) %>% 
#     as.data.frame() %>% `colnames<-`(c(paste0("k_", clust_range_max))) %>% 
#     mutate(across(where(is.numeric),as.factor))
#   
#   clusters = cutree(hc, cluster_number, order_clusters_as_data=T) %>%
#     as.factor() %>% fct_inorder() %>% fct_rev()
#   
#   tmp = GO_data %>%
#     mutate(cluster = factor(clusters[match(ID, names(clusters))])) %>%
#     dplyr::select(c("ID","Description","cluster")) %>% mutate(IC = GO_sem_sim@IC[ID])
#   
#   
#   # Retrieve ancestor GO of go_ids, add cluster number to each ancestor GO, count them with data.table and add Information Content
#   # Then select the most common ancestral GO term (at least in 50% of GOs) with highest Information Content
#   
#   # Obtain representative ancestral GO term by IC^2 (if there is a tie it will return only one term)
#   
#   ### TO DO MAKE SURE ANCESTRAL TERMS ARE SELECTED CORRECTLY
#   
#   tmp = GO_anc[go_ids] %>% stack() %>% 
#     #mutate(CL = tmp$cluster[match(ind,tmp$ID)]) %>% 
#     mutate(cluster = anno_df[,2][match(ind, row.names(anno_df))]) %>% 
#     data.table() %>% .[,.N,by=c("cluster","values")] %>% 
#     mutate(IC = GO_sem_sim@IC[values]) %>% 
#     # to do: group by cluster, add column of n genes by cluster and then select those with N > n/2, then select by IC
#     group_by(cluster) %>% 
#     mutate(min_n = length(cluster)/2)
#   
#   #### to do calculate "all"/2  
#   #### WHY ALL =/= NUMBER OF GOs IN CLUSTER ?!?!
#     mutate(min_n = (filter(., values == "all") %>% pull(N))/2)
#     
#     
#     dplyr::slice(which.max(IC)) %>% 
#     #dplyr::filter(importance == max(importance,na.rm=T)) %>%
#     ungroup() %>% mutate(GO_description = GO_def$TERM[match(values,GO_def$GOID)])
#   
# 
#   # reprGO = tmp2[,.N,by=c("CL","values")] %>% 
#   #   mutate(IC = athGO@IC[values]) %>% 
#   #   #mutate(importance = (N*IC^2)) %>% 
#   #   group_by(CL) %>% 
#   #   dplyr::slice(which.max(IC)) %>% 
#   #   #dplyr::filter(importance == max(importance,na.rm=T)) %>%
#   #   ungroup() %>% mutate(GO_description = GO_def$TERM[match(values,GO_def$GOID)])
#   
#   reprGO



# GO_heatmap = Heatmap(ss_rel,
#                      name = "Similarity",
#                      clustering_method_rows = "ward.D2",
#                      clustering_method_columns = "ward.D2",
#                      col = col_fun,
#                      row_labels = row_labs[rownames(ss_rel)],
#                      row_names_max_width = max_text_width(row_labs),
#                      right_annotation = ha,
#                      show_column_names = FALSE)
# 
# GO_heatmap
# 
# 
# # test = structure(GO_data$p.adjust, names = paste0(GO_IDs))
# # pvalue_col_fun = colorRamp2(c(0, 0.05), c("green", "white"))
# # 
# # ha = HeatmapAnnotation(pvalue = test,
# #                        which = "row",
# #                        annotation_label = "adj. p-val.",
# #                        annotation_name_side="top",
# #                        annotation_name_rot=45,
# #                        col = list(pvalue = pvalue_col_fun),
# #                        annotation_legend_param = list(
# #                          pvalue = list(
# #                            at = c(0, 0.05))))
# 
# dd = (1 - ss_rel) %>% as.dist %>% hclust(method = "ward.D2") %>% as.dendrogram()
# 
# test = cutree(dd, max_crange_pbc) %>% as.data.frame() %>% `colnames<-`(paste0("k_", colnames(.))) %>% mutate_if(is.numeric,as.factor)
# 
# ha = HeatmapAnnotation(df = test,
#                        which = "row",
#                        annotation_label = "cluster",
#                        annotation_name_side="top",
#                        annotation_name_rot=45)
# 
# 
# GO_heatmap = Heatmap(ss_rel,
#                      name = "Similarity",
#                      clustering_method_rows = "ward.D2",
#                      clustering_method_columns = "ward.D2",
#                      col = col_fun,
#                      row_labels = row_labs[rownames(ss_rel)],
#                      row_names_max_width = max_text_width(row_labs),
#                      #right_annotation = ha,
#                      show_column_names = FALSE,
#                      row_km = 9)
# 
# GO_heatmap
# 
# # Visualize GO clustering
# dd = (1 - ss_rel) %>% as.dist %>%
#   hclust(method = "ward.D2") %>% as.dendrogram(hang = -1) %>%
#   set("labels_cex", 0.6)
# 
# labels(dd) = GO_data$Description[match(labels(dd), GO_data$ID)]
# 
# par(mar = c(1, 1, 1, 20),
#     xpd = NA)
# plot(dd, horiz = T)
# 
# 
# # In this case, upon visual inspection (GO_heatmap) we see three clusters. Replot with colors to visualize
# cluster_number = 15
# div_pal = distinctColorPalette(cluster_number)
# 
# clusters = cutree(dd, cluster_number,order_clusters_as_data=T) %>% 
#   as.factor() %>% fct_inorder() %>% fct_rev()
# 
# dd = (1 - ss_rel) %>% as.dist %>%
#   hclust(method = "ward.D2") %>% as.dendrogram(hang = -1) %>%
#   set("labels_cex", 0.6) %>% 
#   set("branches_k_color", k=cluster_number, value = div_pal) %>% 
#   set("labels_col", k=cluster_number, value = div_pal)
# 
# labels(dd) = GO_data$Description[match(labels(dd), GO_data$ID)]
# 
# par(mar = c(1, 1, 1, 20),
#     xpd = NA,
#     bg = "grey50"
#     ) 
# plot(dd, horiz = T)
# 
# # 4- Select representative term for each cluster
# # Retrieve Information Content for each term
# tmp = GO_data %>% 
#   mutate(Cluster = factor(clusters[match(Description, names(clusters))])) %>%
#   dplyr::select(c("ID","Description","Cluster")) %>% mutate(IC = athGO@IC[ID])
# 
# # Retrieve ancestral GO terms
# tmp2 = GO_anc[tmp$ID] %>% stack() %>% 
#   mutate(CL = tmp$Cluster[match(ind,tmp$ID)]) %>% 
#   data.table()
# 
# # Obtain representative ancestral GO term by IC^2 (if there is a tie it will return only one term)
# reprGO = tmp2[,.N,by=c("CL","values")] %>% 
#   mutate(IC = athGO@IC[values]) %>% 
#   mutate(importance = (IC^2)) %>% group_by(CL) %>% 
#   dplyr::slice(which.max(importance)) %>% 
#   #dplyr::filter(importance == max(importance,na.rm=T)) %>%
#   ungroup() %>% mutate(Desc = GO_def$TERM[match(values,GO_def$GOID)])
# 
reprGO


# test = cluster_terms(mat)
# 
# compare_clustering_methods(mat, plot_type = "heatmap")
# 
# #####
# # Clustering of GO enriched terms
# # Generate object with GO Semantic Similarity and Information Content
# 
# 
# # 3- Summarize GO by semantic similarity
# # Get common GO terms and calculate semantic similarity between them
# GO_data = as.data.frame(GOenrich_up) # to query for GO IDs and descriptions
# 
# GO_IDs = GO_data %>% pull(unique(ID))
# ss_rel = mgoSim(GO_IDs, GO_IDs, semData=athGO, measure="Rel", combine=NULL)
# 
# # Calculate optimal cluster number "mathematically"
# #### WeighedCluster
# GO_hclust = (1 - ss_rel) %>% as.dist %>%
#   hclust(method = "ward.D2")
# 
# GO_hclust_n = length(GO_hclust$order)
# 
# clustrange = as.clustrange(GO_hclust, diss=(1 - ss_rel), ncluster = GO_hclust_n)
# 
# # R2 and R2-sq will always give maximum number of clusters as optimal (see WeighedCluster user's guide)
# # RHC is reverse HC, so max value is ideal
# 
# # clustrange_summary = summary(clustrange, max.rank=1) %>% rownames_to_column("method") %>% filter(!(method %in% c("R2","R2sq"))) 
# # 
# # best_cluster = clustrange_summary$`1. N groups` %>% mode_value()
# # 
# # best_cluster
# 
# clustrange_plot = plot(clustrange, 
#                        stat=c("PBC","ASWw", "ASW","HG", "HGSD", "RHC"), 
#                        norm="zscore",lwd=3)
# 
# pamRange <- wcKMedRange((1 - ss_rel), kvals=2:GO_hclust_n)
# # pamrange_summary = summary(pamRange, max.rank=2)
# # best_cluster_pam = pamrange_summary$`1. N groups` %>% mode_value()
# # 
# # best_cluster_pam
# 
# pamrange_plot = plot(pamRange, 
#                      stat=c("PBC","ASWw", "ASW","HG", "HGSD", "RHC"), 
#                      norm="zscore",lwd=3)
# 
# par(mfrow=c(1,2))
# plot(clustrange, 
#      stat=c("PBC","ASWw", "ASW","HG", "HGSD", "RHC"), 
#      norm="zscore",lwd=3)
# plot(pamRange, 
#      stat=c("PBC","ASWw", "ASW","HG", "HGSD", "RHC"), 
#      norm="zscore",lwd=3)
# 
# crange_pbc = clustrange$stats$PBC
# prange_pbc = pamRange$stats$PBC
# 
# max_crange_pbc = find_local_max(crange_pbc)
# max_prange_pbc = find_local_max(prange_pbc)
# 
# max1_crange_pbc = which.max(crange_pbc)
# max1_prange_pbc = which.max(prange_pbc)
# 
# 
# #sapply(pamRange$stats, find_local_max)
# 
# ###
# 
# test = simplify_go(GOenrich_up,
#             GO_sem_sim= athGO,
#             )


# ##### Plot logFC and chip peak strength
# BRC1ind_data
# 
# #csaw_result_filtered = csaw_result[width(csaw_result)>10]
# 
# test = find_overlaps(csaw_result_filtered,ath_3kup_1kdown) %>% `names<-`(paste0(names(.),"_",.$name))
# 
# test2 = as.data.frame(test)
# 
# test3 = BRC1ind_data %>% select("Geneid","logFC_GFP_BRC1ind_vs_brc1")
# 
# test4 = left_join(test2,test3,by = (setNames("Geneid","name")))
# 
# test5 = test4 %>% filter(!is.na(logFC_GFP_BRC1ind_vs_brc1))
# 
# ggplot(test5,aes(log2(score),abs(logFC_GFP_BRC1ind_vs_brc1))) +
#   geom_point()
# 
# 
# 
# 
# 
# 
# ##
# peak_granges = peak_list$HB21
# 
# hb = "hb21"
# fc_column = paste0("logFC_",hb,"i_vs_gus")
# fdr_column = paste0("FDR_",hb,"i_vs_gus")
# 
# hb21_de_data = HBind_data_unfiltered %>% select(Geneid,fc_column,fdr_column) %>% filter(get(fdr_column) < 0.05) %>% 
#   `colnames<-`(c("Geneid","logFC","FDR")) %>% select("Geneid","logFC")
# 
# peak_data = find_overlaps(peak_granges,ath_3kup_1kdown) %>% `names<-`(paste0(.$name.x,"_",.$name.y)) %>% as.data.frame
# 
# diffexp_data = hb21_de_data
# 
# data_for_plot = left_join(peak_data,diffexp_data,by = (setNames("Geneid","name.y"))) %>% drop_na()
# 
# ggplot(data_for_plot, aes(x=log2(signalValue),y=(logFC))) +
#   geom_point()



#fiter csaw by >10 and positive score
# filtered_list2 = lapply(list2, function(x) { plyranges::mutate(x,peak_width = width(x)) } ) %>% 
#   lapply(., function(x) { plyranges::filter(x,peak_width >10)}) %>% 
#   lapply(., function(x) { plyranges::filter(x,score>0)}) %>% `names<-`(paste0(peak_file_names,"_fil"))




# ### To do: retrieve SMXL expression level in buds
# feature_counts = fread("./input/2022_03_10_feature_counts_experiment_1_exons.txt")
# counts = feature_counts %>% dplyr::select(-c(Geneid,Chr,Start,End,Strand,Length)) %>% `colnames<-`(sample_names)
# gene_info = feature_counts %>% dplyr::select(c(Geneid,Chr,Start,End,Strand,Length))
# sample_groups = gsub('.{2}$', '', sample_names) %>% factor(levels=unique(gsub('.{2}$', '', sample_names)))
# 
# # Build design and contrasts for statistical tests
# design = model.matrix(~0+sample_groups) %>% `colnames<-`(levels(sample_groups))
# 
# # Build DGEList object and normalize by library size
# DGEL_object = DGEList(counts = counts, 
#                       genes = gene_info,
#                       group = sample_groups) %>% calcNormFactors()
# 
# # Create RPKM object
# RPKM_object = rpkm(DGEL_object, gene.length = "Length") %>% as.data.frame %>% cbind("gene_id"=DGEL_object$genes$Geneid,.)
# 
# test = add_gene_annotation(RPKM_object,gene_id_column = "gene_id")
# 
# test %>% dplyr::filter(!grepl("BRC1",gene_symbol))
# 
# test %>% filter(str_detect(gene_symbol, "SMXL6|SMXL7|SMXL8")) %>% select(c("gene_id","gene_symbol",contains("ctr")))
# 
# write.table(test, file = paste0("./output/",exp_name,"RPKM_exon_count.txt"), row.names=F, sep="\t", quote=F)
# 
# ####
# ```
# 
# Compare with JR featurecounts data:
# ```{r}
# feature_counts_rds = readRDS("./input/featureCounts.rds")
# 
# feature_counts = cbind(feature_counts_rds$annotation, feature_counts_rds$counts) %>% dplyr::rename(Geneid ="GeneID")
# 
# # Experiment name and date of analysis for output files:
# exp_name = paste0(format(Sys.Date(),"%Y_%m_%d"), "_HBind_")
# 
# # Extract data to build DGEList object to process with edgeR
# sample_names = c("gus_1","gus_2","gus_3",
#                  "hb21i_1","hb21i_2","hb21i_3",
#                  "hb40i_1","hb40i_2","hb40i_3",
#                  "hb53i_1","hb53i_2","hb53i_3")
# 
# counts = feature_counts %>% dplyr::select(-c(Geneid,Chr,Start,End,Strand,Length)) %>% dplyr::select(19:30) %>% `colnames<-`(sample_names)
# gene_info = feature_counts %>% dplyr::select(c(Geneid,Chr,Start,End,Strand,Length))
# sample_groups = gsub('.{2}$', '', sample_names) %>% factor(levels=unique(gsub('.{2}$', '', sample_names)))
# 
# DGEL_object = DGEList(counts = counts, 
#              genes = gene_info,
#              group = sample_groups) %>% calcNormFactors()
# 
# # Create RPKM object
# RPKM_object = rpkm(DGEL_object, gene.length = "Length") %>% as.data.frame %>% cbind("gene_id"=DGEL_object$genes$Geneid,.)
# 
# write.table(RPKM_object, file = paste0("./output/",exp_name,"RPKM_JR.txt"), row.names=F, sep="\t", quote=F)
# 
# # Remove genes with low RPKM counts
# RPKM_cutoff = 1
# 
# drop = DGEL_object %>% rpkm %>% rowMeans %>% `<`(RPKM_cutoff) %>% which #get index of genes below threshold
# 
# DGEL_object_filtered = DGEL_object[-drop, ,keep.lib.sizes=FALSE] %>% calcNormFactors
# 
# # MDS plot (distance calculated from 500 top genes with highest deviation pairwise between groups
# mds = plotMDS(DGEL_object_filtered, plot=FALSE)
# dim1_label = paste0(mds$axislabel," 1 (",(mds$var.explained[1] * 100 ) %>% round(1)," %)")
# dim2_label = paste0(mds$axislabel," 2 (",(mds$var.explained[2] * 100 ) %>% round(1)," %)")
# 
# MDS_plot = data.frame(Dim1 = mds$x, Dim2 = mds$y, Group = DGEL_object_filtered$samples$group) %>% 
#   mutate(treatment = recode(Group, 
#                             "gus" = "GUSind",
#                             "hb21i" = "HB21ind",
#                             "hb40i" = "HB40ind",
#                             "hb53i" = "HB53ind"))
# 
# custom_jco = pal_jco("default")(4)[c(3,1,2,4)]
# 
# ggplot(MDS_plot, aes(x=Dim1, y=Dim2, color = treatment)) + 
#   geom_point() +
#   scale_color_manual(values = custom_jco) +
#   labs(x = dim1_label,
#        y = dim2_label) +
#   geom_dl(aes(label = treatment),
#           method = "smart.grid") +
#   coord_cartesian(clip = "off") +
#   theme(aspect.ratio = 1,
#         legend.position = "left",
#         legend.text = element_text(size = 10),
#         legend.text.align = 0,
#         legend.spacing.x = unit(0.5, "mm"),
#         legend.title = element_blank(),
#         legend.key=element_blank())
# 
# # Build model and test all against control (wt_ctr)
# design = model.matrix(~0+sample_groups) %>% `colnames<-`(levels(sample_groups))
# 
# DGEL_object_filtered = estimateDisp(DGEL_object_filtered, design, robust=TRUE)
# 
# fit = glmQLFit(DGEL_object_filtered, design, robust=TRUE)
# 
# my_contrasts = makeContrasts(hb21i_vs_gus=hb21i-gus,
#                              hb40i_vs_gus=hb40i-gus,
#                              hb53i_vs_gus=hb53i-gus,
#                              levels=design)
# 
# test_list = list()
# 
# for(contrast in colnames(my_contrasts)) {
#   print(contrast)
#   test_list[[contrast]] = glmQLFTest(fit, contrast=my_contrasts[,contrast]) %>% topTags(n = Inf) %>% as.data.frame() %>% 
#     rename_with( ~ paste(.x, contrast, sep = "_"), .cols = c("logFC","logCPM","F","PValue","FDR"))
# }
# 
# merged_tests = test_list %>% purrr::reduce(left_join, by = c("Geneid","Chr","Start","End","Strand","Length"))
# 
# FDRts = 0.05 #set FDR threshold
# FCts = log2(2) #set Fold change threshold
# 
# fdr_colnames = colnames(merged_tests)[grepl("^FDR",colnames(merged_tests))]
# contrast_colnames = colnames(merged_tests)[grepl("^logFC",colnames(merged_tests))]
# 
# filtered_tests = merged_tests %>% 
#   filter(if_any(all_of(fdr_colnames), ~ (.) < FDRts)) %>% 
#   filter(if_any(all_of(contrast_colnames), ~ abs(.) > FCts))
# 
# # Add gene name and description to output file and remove extra columns
# extra_columns = colnames(merged_tests)[grepl(c("^logCPM|^F_|^PValue"),colnames(merged_tests))]
# filtered_tests_output = filtered_tests %>% add_gene_annotation %>% dplyr::select(-all_of(extra_columns))
# 
# write.table(filtered_tests_output, file = paste0("./output/",exp_name,"_filtered_tests_JR.txt"), row.names=F, sep="\t", quote=F, na="")
# ```
# 
# Extra code:
# ```{r}
# 
# ###### Use edgeR with macs2 consensus peaks for quantification
# # Merge peaks called in at least 2 replicates (adapted from https://ro-che.info/articles/2018-07-11-chip-seq-consensus)
# # Import MACS2 output. Select the least restrictive MACS2 peaks (no qvalue filter, q1)
# peak_file_list = list.files(path = "./input/", pattern="^BRC1_ChIP.*q1.*\\.narrowPeak$", full.names=TRUE)
# 
# peak_grangeslist = sapply(peak_file_list, read_narrowpeaks) %>% `names<-`(peak_file_list %>% str_extract("BRC1_ChIP*.")) %>% GRangesList
# 
# peak_coverage = coverage(peak_grangeslist)
# #peak_coverage
# 
# # Make GRanges and add column names to parse to GFF
# covered_ranges = IRanges::slice(peak_coverage, lower=2, rangesOnly=T) %>% GRanges %>% 
#   mutate(gene_id = paste0("peak_",rep(1:length(.)))) %>% 
#   mutate(name = gene_id) %>% 
#   mutate(type = rep("gene",length(.)))
# 
# write_bed(covered_ranges, file = "./output/macs2_consensus.bed")
# write_gff3(covered_ranges, file = "./output/macs2_consensus.gff")
# 
# 
# ###### Use edgeR with macs2 consensus peaks for quantification
# ## To do peak calling with MACS with high qvalue threshold to obtain peaks that are not enriched for edgeR
# 
# 
# # Use edgeR with macs2 consensus peaks for quantification
# feature_counts = fread("./input/2022_03_10_feature_counts_macs2_consensus.txt")
# feature_counts = feature_counts[,c(1:6,10:12,7:9)]
# 
# # Extract data to build DGEList object to process with edgeR
# sample_names = c("Input2","Input3","Input7",
#                  "ChIP2","ChIP3","ChIP7")
# 
# counts = feature_counts %>% dplyr::select(-c(Geneid,Chr,Start,End,Strand,Length)) %>% `colnames<-`(sample_names)
# gene_info = feature_counts %>% dplyr::select(c(Geneid,Chr,Start,End,Strand,Length))
# sample_groups = gsub('.{1}$', '', sample_names) %>% factor(levels=unique(gsub('.{1}$', '', sample_names)))
# 
# # Build DGEList object and normalize by library size
# DGEL_object = DGEList(counts = counts, 
#                       genes = gene_info,
#                       group = sample_groups) %>% calcNormFactors()
# 
# ##
# # DGEL_object = DGEL_object[filterByExpr(DGEL_object), ,keep.lib.sizes=FALSE] #remove genes with low counts and recalculate library size
# # 
# # DGEL_object = calcNormFactors(DGEL_object)
# 
# 
# design = model.matrix(~sample_groups)
# 
# DGEL_object <- estimateDisp(DGEL_object, design, robust=TRUE)
# fit <- glmQLFit(DGEL_object, design, robust=TRUE)
# results <- glmQLFTest(fit)
# 
# edgeR_MACS2_output = as.data.frame(results) %>% 
#   # filter(PValue < 0.05) %>% 
#   #dplyr::rename(name = "Geneid", score = "logFC") %>% 
#   mutate(name = paste0(Geneid,"_logFC_",round(logFC,3))) %>% GRanges
# 
# write_bed(edgeR_MACS2_output, file="./output/edgeR_MACS2_logFC.bed")
# 
# edgeR_MACS2_output = as.data.frame(results) %>% 
#   # filter(PValue < 0.05) %>% 
#   #dplyr::rename(name = "Geneid", score = "logFC") %>% 
#   mutate(name = paste0(Geneid,"_PVal_",round(PValue,4))) %>% GRanges
# 
# write_bed(edgeR_MACS2_output, file="./output/edgeR_MACS2_PVal.bed")



### map to entrez id
# names(genes_up)
# 
# db_ensembl_id = AnnotationDbi::select(org.At.tair.db,
#                                            column = "ENTREZID",
#                                            keys = names(genes_up),
#                                            keytype = "TAIR",
#                                            multiVals = "first")
# 
# 
# bm_ensembl_id = getBM(attributes = c("tair_locus","entrezgene_id"),
#                             filters = "tair_locus",
#                             values = names(genes_up),
#                             mart = ensembl)
# 
# test = full_join(db_ensembl_id,bm_ensembl_id, by = c("TAIR" = "tair_locus"))
# ###
# pathways.list <- keggList("pathway", "ath")
# 
# pathway.codes <- sub("path:", "", names(pathways.list)) 
# 
# genes.by.pathway <- sapply(pathway.codes,
#     function(pwid){
#         pw <- keggGet(pwid)
#         if (is.null(pw[[1]]$GENE)) return(NA)
#         pw2 <- pw[[1]]$GENE[c(TRUE,FALSE)] # may need to modify this to c(FALSE, TRUE) for other organisms
#         pw2 <- unlist(lapply(strsplit(pw2, split = ";", fixed = T), function(x)x[1]))
#         return(pw2)
#     }
# )
# head(genes.by.pathway)
# 
# test2 = test %>% filter(!is.na(ENTREZID)) %>% pull(TAIR)
# 
# for(g in test2){
#   print(any(sapply(genes.by.pathway,function(x) g %in% x)))
# }
# 
# ###


# #  Pair-wise comparisons
# design = model.matrix(~0+sample_groups) %>% `colnames<-`(levels(sample_groups))
# 
# contr = makeContrasts(hb21ivsgus = hb21i - gus,
#                       hb40ivsgus = hb40i - gus,
#                       hb53ivsgus = hb53i - gus,
#                       levels = design)
# 
# DGL_object_filtered = estimateDisp(DGL_object_filtered, design, robust=TRUE)
# 
# fit = glmQLFit(DGL_object_filtered, design, robust=TRUE)
# 
# qlf_test = glmQLFTest(fit, contrast = contr) 
# 
# FDRts = 0.05 #set FDR threshold
# FCts = log2(2) #set Fold change threshold
# 
# all_vs_ctr = topTags(qlf_test, n = Inf, p.value = FDRts)
# 
# 
# 
# 
# 
# 
# 
# 
# ##############
# # Build model and make contrasts to obtain FC
# 
# design_pairwise = model.matrix(~0+sample_groups) %>% `colnames<-`(levels(sample_groups))
# 
# # To do make contrasts and loop edgeR through each contrast
# design.pairs <-
# function(levels) {
# n <- length(levels)
# design <- matrix(0,n,choose(n,2))
# rownames(design) <- levels
# colnames(design) <- 1:choose(n,2)
# k <- 0
# for (i in 1:(n-1))
# for (j in (i+1):n) {
# k <- k+1
# design[i,k] <- 1
# design[j,k] <- -1
# colnames(design)[k] <- paste(levels[i],"-",levels[j],sep="")
# }
# design
# }
# 
# #make contrasts and use in edgeR loop and join results by gene_id
# unique(sample_groups) %>% design.pairs
# 
# # correct p-val with p.adjust(p, method = "fdr")   p = unadjusted pvalue of all comparisons

# superscript_function = function(x){
#   a = str_sub(x,1,-4)
#   b = str_sub(x,-3,-1)
#   paste0(a,"^",b)
# }


# To check which method of geom_dl work best

# label_methods = c("ahull.grid","chull.grid","extreme.grid","smart.grid")
# 
# plot_label_methods = function(method) {
#   ggplot(data = RPKM_PCA_PLOT, aes(x = PC1, y = PC2, color = genotype)) +
#     geom_point(alpha = 1) +
#     geom_dl(aes(label = genotype),
#             method = method) +
#     labs(title = method,
#          color = "Treatment",
#          x = paste0("PC1: ",round(RPKM_PCA_pv[1],2),"% var"),
#          y = paste0("PC2: ",round(RPKM_PCA_pv[2],2),"% var")) +
#     scale_color_manual(values = custom_jco) +
#     scale_fill_manual(values = custom_jco) +
#     coord_cartesian(clip = "off") +
#     theme(aspect.ratio = 1,
#           legend.position = "left",
#           legend.text = element_text(size = 10),
#           legend.spacing.x = unit(0.5, "mm"),
#           legend.title.align = 0.5,
#           legend.key=element_blank())
# }
# 
# myplots <- lapply(label_methods, plot_label_methods)
# grid.arrange(grobs = myplots)


#####
# Build model and make contrasts to obtain FC

# design_pairwise = model.matrix(~0+sample_groups) %>% `colnames<-`(levels(sample_groups))
# 
# # To do make contrasts and loop edgeR through each contrast
# design.pairs <-
# function(levels) {
# n <- length(levels)
# design <- matrix(0,n,choose(n,2))
# rownames(design) <- levels
# colnames(design) <- 1:choose(n,2)
# k <- 0
# for (i in 1:(n-1))
# for (j in (i+1):n) {
# k <- k+1
# design[i,k] <- 1
# design[j,k] <- -1
# colnames(design)[k] <- paste(levels[i],"-",levels[j],sep="")
# }
# design
# }
# 
# #make contrasts and use in edgeR loop and join results by gene_id
# unique(sample_groups) %>% design.pairs
```

OLD Experiment 1: wt, brc1, hb21hb40hb53; control/+ABA
```{r}
# Read featureCounts output
exp_name = "experiment_1_"
feature_counts = fread("./input/2022_03_05_feature_counts_experiment_1_gene_hisat2.txt")

# Extract data to build DGEList object to process with edgeR
sample_names = c("wt_ctr_1","wt_ctr_2","wt_ctr_3",
                 "wt_aba_1","wt_aba_2","wt_aba_3",
                 "tri_ctr_1","tri_ctr_2","tri_ctr_3",
                 "tri_aba_1","tri_aba_2","tri_aba_3",
                 "brc1_ctr_1","brc1_ctr_2","brc1_ctr_3",
                 "brc1_aba_1","brc1_aba_2","brc1_aba_3")
counts = feature_counts %>% dplyr::select(-c(Geneid,Chr,Start,End,Strand,Length)) %>% `colnames<-`(sample_names)
gene_info = feature_counts %>% dplyr::select(c(Geneid,Chr,Start,End,Strand,Length))
sample_groups = gsub('.{2}$', '', sample_names) %>% factor(levels=unique(gsub('.{2}$', '', sample_names)))

# Build DGEList object and normalize by library size
DGEL_object = DGEList(counts = counts, 
                      genes = gene_info,
                      group = sample_groups) %>% calcNormFactors()

# Create RPKM object
RPKM_object = rpkm(DGEL_object, gene.length = "Length") %>% as.data.frame %>% cbind("gene_id"=DGEL_object$genes$Geneid,.)

write.table(RPKM_object, file = paste0("./output/",exp_name,"RPKM.txt"), row.names=F, sep="\t", quote=F)

# Remove genes with low RPKM counts
RPKM_cutoff = 1

drop = DGEL_object %>% rpkm %>% rowMeans %>% `<`(RPKM_cutoff) %>% which #get index of genes below threshold

DGEL_object_filtered = DGEL_object[-drop, ,keep.lib.sizes=FALSE] %>% calcNormFactors

# PCA plot
RPKM = (rpkm(DGEL_object_filtered,log = T))
RPKM_PCA = prcomp(t(RPKM))
RPKM_PCA_pv = ((RPKM_PCA$sdev^2) / (sum(RPKM_PCA$sdev^2)))*100
RPKM_PCA_data = RPKM_PCA$x[,1:2]

RPKM_PCA_PLOT = RPKM_PCA_data %>% as.data.frame %>%
  rownames_to_column("SampleID") %>%
  separate(SampleID,into=c("genotype","replicate"), sep="_(?!.*_)",remove=FALSE) %>% 
  mutate_if(is.character, as.factor) %>% 
  mutate(genotype = factor(genotype, levels = c("wt_ctr","wt_aba","tri_ctr","tri_aba","brc1_ctr","brc1_aba"))) %>% 
  mutate(genotype = recode(genotype, 
                           "wt_ctr" = "wt",
                           "wt_aba" = "wt + ABA",
                           "tri_ctr" = "hb21hb40hb53",
                           "tri_aba" = "hb21hb40hb53 + ABA",
                           "brc1_ctr" = "brc1",
                           "brc1_aba" = "brc1 + ABA"))

legend_labels = RPKM_PCA_PLOT$genotype %>% levels

custom_jco = c("#868686FF","#565656","#0073C2FF", "#005693","#EFC000FF", "#BE9800")

custom_jco = 1:6
RPKM_PCA_PLOT2 = RPKM_PCA_PLOT %>% filter(genotype %in% c("wt", "hb21hb40hb53", "brc1"))

PCA_plot = ggplot(data = RPKM_PCA_PLOT, aes(x = PC1, y = PC2, color = genotype)) +
  geom_point(alpha = 1) +
  # geom_dl(aes(label = genotype),
  #         method = "smart.grid") +
  labs(x = paste0("PC1: ",round(RPKM_PCA_pv[1],2),"% var"),
       y = paste0("PC2: ",round(RPKM_PCA_pv[2],2),"% var")) +
  scale_color_manual(values = custom_jco, labels = legend_labels) +
  scale_fill_manual(values = custom_jco) +
  coord_cartesian(clip = "off") +
  theme(aspect.ratio = 1,
        legend.position = "left",
        legend.text = element_text(size = 10),
        legend.text.align = 0,
        legend.spacing.x = unit(0.5, "mm"),
        legend.title = element_blank(),
        legend.key=element_blank())

# Build model and test all against control (wt_ctr)
design = model.matrix(~sample_groups) %>% `colnames<-`(levels(sample_groups))

DGEL_object_filtered = estimateDisp(DGEL_object_filtered, design, robust=TRUE)

fit = glmQLFit(DGEL_object_filtered, design, robust=TRUE)

qlf_test = glmQLFTest(fit, coef=2:6) #compares all the samples to the control (ANOVA-like test)

all_vs_ctr = topTags(qlf_test, n = Inf) #unfiltered data

FDRts = 0.05 #set FDR threshold
FCts = log2(2) #set Fold change threshold

contrast_colnames = colnames(qlf_test)[grepl("^logFC",colnames(qlf_test))]

all_vs_ctr = topTags(qlf_test, n = Inf, p.value = FDRts) %>% 
  data.frame %>% filter(if_any(all_of(contrast_colnames), ~ abs(.) > FCts))

# Add gene name and description to output file
all_vs_ctr_output = all_vs_ctr %>% add_gene_annotation

write.table(all_vs_ctr_output, file = paste0("./output/",exp_name,"all_vs_ctr.txt"), row.names=F, sep="\t", quote=F, na="")

###
counts2 = counts %>% dplyr::select(contains("ctr"))

sample_groups2 = gsub('.{2}$', '', colnames(counts2)) %>% factor(levels=unique(gsub('.{2}$', '', colnames(counts2))))

DGEL_object2 = DGEList(counts = counts2, 
                       genes = gene_info,
                       group = sample_groups2) %>% calcNormFactors()

RPKM_cutoff = 1

drop = DGEL_object2 %>% rpkm %>% rowMeans %>% `<`(RPKM_cutoff) %>% which #get index of genes below threshold

DGEL_object2_filtered = DGEL_object2[-drop, ,keep.lib.sizes=FALSE] %>% calcNormFactors

# PCA plot
RPKM = (rpkm(DGEL_object2_filtered,log = T))
RPKM_PCA = prcomp(t(RPKM))
RPKM_PCA_pv = ((RPKM_PCA$sdev^2) / (sum(RPKM_PCA$sdev^2)))*100
RPKM_PCA_data = RPKM_PCA$x[,1:2]

RPKM_PCA_PLOT = RPKM_PCA_data %>% as.data.frame %>%
  rownames_to_column("SampleID") %>%
  separate(SampleID,into=c("genotype","replicate"), sep="_(?!.*_)",remove=FALSE) %>% 
  mutate_if(is.character, as.factor) %>% 
  mutate(genotype = factor(genotype, levels = c("wt_ctr","tri_ctr","brc1_ctr"))) %>% 
  mutate(genotype = recode(genotype, 
                           "wt_ctr" = "wt",
                           "tri_ctr" = "hb21hb40hb53",
                           "brc1_ctr" = "brc1"))

legend_labels = RPKM_PCA_PLOT$genotype %>% levels

custom_jco = c("#868686FF","#0073C2FF", "#EFC000FF")

PCA_plot = ggplot(data = RPKM_PCA_PLOT, aes(x = PC1, y = PC2, color = genotype)) +
  geom_point(alpha = 1) +
  # geom_dl(aes(label = genotype),
  #         method = "smart.grid") +
  labs(x = paste0("PC1: ",round(RPKM_PCA_pv[1],2),"% var"),
       y = paste0("PC2: ",round(RPKM_PCA_pv[2],2),"% var")) +
  scale_color_manual(values = custom_jco, labels = legend_labels) +
  scale_fill_manual(values = custom_jco) +
  coord_cartesian(clip = "off") +
  theme(aspect.ratio = 1,
        legend.position = "left",
        legend.text = element_text(size = 10),
        legend.text.align = 0,
        legend.spacing.x = unit(0.5, "mm"),
        legend.title = element_blank(),
        legend.key=element_blank())

# Selected comparisons:
design = model.matrix(~sample_groups2) %>% `colnames<-`(levels(sample_groups2))

DGEL_object2_filtered = estimateDisp(DGEL_object2_filtered, design, robust=TRUE)

fit = glmQLFit(DGEL_object2_filtered, design, robust=TRUE)

qlf_test = glmQLFTest(fit, coef=2:3)

FDRts = 0.05 #set FDR threshold
FCts = log2(2) #set Fold change threshold

contrast_colnames = colnames(qlf_test)[grepl("^logFC",colnames(qlf_test))]

all_vs_ctr = topTags(qlf_test, n = Inf, p.value = FDRts) %>% 
  data.frame %>% filter(if_any(all_of(contrast_colnames), ~ abs(.) > FCts))

# Add gene name and description to output file
all_vs_ctr_output = all_vs_ctr %>% add_gene_annotation

### To do write output file
write.table(all_vs_ctr_output, file = paste0("./output/",exp_name,"brc1_tri_vs_ctr.txt"), row.names=F, sep="\t", quote=F, na="")

#####
# Build model and make contrasts to obtain FC

design_pairwise = model.matrix(~0+sample_groups) %>% `colnames<-`(levels(sample_groups))

# To do make contrasts and loop edgeR through each contrast
design.pairs <-
  function(levels) {
    n <- length(levels)
    design <- matrix(0,n,choose(n,2))
    rownames(design) <- levels
    colnames(design) <- 1:choose(n,2)
    k <- 0
    for (i in 1:(n-1))
      for (j in (i+1):n) {
        k <- k+1
        design[i,k] <- 1
        design[j,k] <- -1
        colnames(design)[k] <- paste(levels[i],"-",levels[j],sep="")
      }
    design
  }

#make contrasts and use in edgeR loop and join results by gene_id
unique(sample_groups) %>% design.pairs
```
